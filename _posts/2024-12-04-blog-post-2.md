Curso de **Platzi** donde se aprende conceptos como funciones, comprehensions, errores y manejo de archivos que elevar치n tu nivel al programar.

# Python: Comprehensions, Funciones y Manejo de Errores

Uso de [Replit](https://replit.com/@NicolasMolina13/Python-102#main.py) para ejecutar c칩digo de Python Online.

## Zen de Python

```python
import this
```
```
Los principios est치n listados a continuaci칩n:

    Bello es mejor que feo.
    Expl칤cito es mejor que impl칤cito.
    Simple es mejor que complejo.
    Complejo es mejor que complicado.
    Plano es mejor que anidado.
    Espaciado es mejor que denso.
    La legibilidad es importante.
    Los casos especiales no son lo suficientemente especiales como para romper las reglas.
    Sin embargo la practicidad le gana a la pureza.
    Los errores nunca deber칤an pasar silenciosamente.
    A menos que se silencien expl칤citamente.
    Frente a la ambig칲edad, evitar la tentaci칩n de adivinar.
    Deber칤a haber una, y preferiblemente solo una, manera obvia de hacerlo.
    A pesar de que eso no sea obvio al principio a menos que seas Holand칠s.
    Ahora es mejor que nunca.
    A pesar de que nunca es muchas veces mejor que *ahora* mismo.
    Si la implementaci칩n es dif칤cil de explicar, es una mala idea.
    Si la implementaci칩n es f치cil de explicar, puede que sea una buena idea.
    Los espacios de nombres son una gran idea, 춰tengamos m치s de esos!
```
## Conjuntos

[Conjuntos](https://www.w3schools.com/python/python_sets.asp)

Trabajando con conjuntos (Sets)
- Se pueden modificar.
- No tienen un orden.
- No permite duplicados.

```python
set_countries = {'col', 'mex', 'bol'}
print(set_countries)
print(type(set_countries))

set_numbers = {1, 2, 2, 443, 23}
print(set_numbers)

set_types = {1, 'hola', False, 12.12}
print(set_types)

set_from_string = set('hoola')
print(set_from_string)

set_from_tuples = set(('abc', 'cbv', 'as', 'abc'))
print(set_from_tuples)

numbers = [1,2,3,1,2,3,4]
set_numbers = set(numbers)
print(set_numbers)
unique_numbers = list(set_numbers)
print(unique_numbers)
```
```
{'col', 'bol', 'mex'}
<class 'set'>
{1, 2, 443, 23}
{False, 1, 'hola', 12.12}
{'h', 'a', 'o', 'l'}
{'as', 'cbv', 'abc'}
{1, 2, 3, 4}
[1, 2, 3, 4]
```

### Modificando conjuntos

```python
set_countries = {'col', 'mex', 'bol'}

size = len(set_countries)
print(size)

print('col' in set_countries)
print('pe' in set_countries)

# add
set_countries.add('pe')
print(set_countries)
set_countries.add('pe')
print(set_countries)

# update
set_countries.update({'ar', 'ecua', 'pe'})
print(set_countries)

# remove

set_countries.remove('col')
print(set_countries)

set_countries.remove('ar')
set_countries.discard('arg')
print(set_countries)
set_countries.add('arg')
print(set_countries)
set_countries.clear()
print(set_countries)
print(len(set_countries))
```
```
3
True
False
{'bol', 'col', 'pe', 'mex'}
{'bol', 'col', 'pe', 'mex'}
{'bol', 'col', 'ar', 'pe', 'ecua', 'mex'}
{'bol', 'ar', 'pe', 'ecua', 'mex'}
{'bol', 'pe', 'ecua', 'mex'}
{'bol', 'arg', 'pe', 'ecua', 'mex'}
set()
0
```
### Operaciones con conjuntos 

<https://www.w3schools.com/python/python_ref_set.asp> 
![Set_oper](/images/basic_python/sets_oper.png)

```python
set_a = {'col', 'mex', 'bol'}
set_b = {'pe', 'bol'}

# Union
set_c = set_a.union(set_b)
print(set_c)
print(set_a | set_b)

# Intersection
set_c = set_a.intersection(set_b)
print(set_c)
print(set_a & set_b)

# Difference
set_c = set_a.difference(set_b)
print(set_c)
print(set_a - set_b)

# Symmetric Difference
set_c = set_a.symmetric_difference(set_b)
print(set_c)
print(set_a ^ set_b)
```
```
{'mex', 'bol', 'col', 'pe'}
{'mex', 'bol', 'col', 'pe'}
{'bol'}
{'bol'}
{'mex', 'col'}
{'mex', 'col'}
{'mex', 'col', 'pe'}
{'mex', 'col', 'pe'}
```

### Test: Elimina elementos duplicados usando conjuntos
```python
countries = {"MX", "COL", "ARG", "USA"}
northAm = {"USA", "CANADA"}
centralAm = {"MX", "GT", "BZ"}
southAm = {"COL", "BZ", "ARG"}

new_set = set()
# Escribe tu soluci칩n 游녢
new_set = countries.union(northAm, centralAm, southAm)
print(new_set)
```
```
{'BZ', 'GT', 'ARG', 'MX', 'CANADA', 'USA', 'COL'}
```

# Comprehensions
<https://www.w3schools.com/python/python_lists_comprehension.asp>

## Estructura b치sica de List Comprehension
```python
[elemento for elemento in iterable if condition]
```
### Ejemplo
```python
numbers = []
for i in range(1, 11):
  if i % 2 == 0:
    numbers.append(i * 2)

print(numbers)

numbers_v2 = [i * 2 for i in range(1, 11) if i % 2 == 0]
print(numbers_v2)
```

## Estructura b치sica de Dictionary Comprehension

```python
{key:value for var in iterable}

{key:value for var in iterable if condition}
```

### Ejemplo

```python
names = ['rigo', 'mari', 'robe']
ages = [12, 56, 98]

print(list(zip(names, ages)))

new_dict = {name: age for (name, age) in zip(names, ages)}
print(new_dict)
```
```
[('rigo', 12), ('mari', 56), ('robe', 98)]
{'rigo': 12, 'mari': 56, 'robe': 98}
```


```python
import random
countries = ['cub', 'crc', 'pan', 'urg']

population_v2 = { country: random.randint(20, 40)  for country in countries}
print(population_v2)

result = { country: population for (country, population) in population_v2.items() if population > 25 }
print(result)

text = 'Buenas, me presento soy Rigo'
unique = { c: c.upper() for c in text if c in 'aeiou' }
print(unique)
```
```
{'cub': 31, 'crc': 24, 'pan': 22, 'urg': 34}
{'cub': 31, 'urg': 34}
{'u': 'U', 'e': 'E', 'a': 'A', 'o': 'O', 'i': 'I'}
```

### Test: Crea una lista usando List Comprehension
```python
numbers = [35, 16, 10, 34, 37, 25]

even_numbers = []
for number in numbers:
  if number % 2 == 0:
    even_numbers.append(number)
print('v1 =>', even_numbers)

# Ahora usando List Comprehension 游녢
even_numbers_v2 = [val for val in numbers if val%2==0]

print('v2 =>', even_numbers_v2)
```
```
v1 => [16, 10, 34]

v2 => [16, 10, 34]
```

## List vs Tuple vs Set

![Comparation](/images/basic_python/basic_structure_data_comp.png)

> En el contexto de listas, tuplas y conjuntos en Python, "ordenada" significa que los elementos mantienen un orden espec칤fico basado en la secuencia en que fueron a침adidos. Esto permite acceder a los elementos por su 칤ndice, realizar b칰squedas en rangos espec칤ficos y mantener la posici칩n de los elementos. Es importante destacar que tanto las listas como las tuplas son estructuras de datos ordenadas, mientras que los conjuntos no tienen un orden definido.

# Funciones
<https://www.w3schools.com/python/python_functions.asp>

## Intro Funciones

```python
print('Hola Mundo!!')

def my_print(texto):
  print(texto * 4)

my_print('Texto de prueba')
my_print('Hola Mundo!!')

a = 10
b = 90

c = a + b


def func_suma(a, b):
  print(a + b)

func_suma(1 ,5)
func_suma(10, 4)
```
```
Hola Mundo!!
Texto de pruebaTexto de pruebaTexto de pruebaTexto de prueba
Hola Mundo!!Hola Mundo!!Hola Mundo!!Hola Mundo!!
6
14
```
## Funciones: return

El concepto de return en funciones de Python permite que una funci칩n env칤e un valor de vuelta al lugar donde fue llamada. Cuando se utiliza return, la funci칩n termina su ejecuci칩n y el valor especificado se asigna a la variable que recibi칩 la llamada. Esto hace que las funciones sean m치s vers치tiles y reutilizables, ya que se pueden usar para procesar datos y devolver resultados que pueden ser utilizados en otras partes del c칩digo. As칤, facilitan la creaci칩n de programas m치s organizados y mantenibles.


### Ejemplo

```python
def sum_with_range(min, max):
  print(min, max)
  sum = 0
  for x in range(min, max):
    sum += x
  return sum

result = sum_with_range(1, 10)
print(result)
result_2 = sum_with_range(result, result + 10)
print(result_2)
```
```
1 10
45
45 55
```
## Funciones: return & args

Podemos en las funciones tener par치metros por defecto y la capacidad de retornar m칰ltiples valores.

### Ejemplo
```python
def find_volume(length=1, width=1, depth=1):
  return length * width * depth, width, 'hola'

result, width, text = find_volume(width=10)

print(result)
print(width)
print(text)
```
```
10
10
hola
```
## Scope

![Scope](/images/basic_python/scope.png)

El scope, o alcance, se refiere a la visibilidad y duraci칩n de las variables en tu c칩digo. Hay diferentes tipos de scope:

- **Local Scope**: Las variables est치n disponibles solo dentro de la funci칩n o bloque donde fueron definidas.
- **Global Scope**: Las variables pueden ser accedidas desde cualquier parte del archivo.
- **Enclosing Scope**: Se refiere a funciones anidadas, donde la variable de la funci칩n externa es accesible en la interna.

Cada 치mbito tiene su propia jerarqu칤a y comprensi칩n del scope es crucial para evitar errores.

### Ejemplo
```python
price = 100 # global
# result = 200

def increment():
  price = 200
  result = price + 10
  print(result)
  return result

print(price)
price_2 = increment()
print(price_2)
# print(result)
```
```
100
210
210
```

## Refactor

> Refactorizar es el proceso de reestructurar el c칩digo existente sin cambiar su funcionalidad externa. Su objetivo es mejorar la legibilidad, mantenibilidad y reducir la complejidad del c칩digo. En este contexto se aplica durante la refactorizaci칩n del juego de piedra, papel o tijera, donde se dividieron grandes bloques de c칩digo en funciones m치s peque침as con responsabilidades espec칤ficas, facilitando as칤 su comprensi칩n y mantenimiento.


```python
import random


def choose_options():
  options = ('piedra', 'papel', 'tijera')
  user_option = input('piedra, papel o tijera => ')
  user_option = user_option.lower()

  if not user_option in options:
    print('esa opcion no es valida')
    # continue
    return None, None

  computer_option = random.choice(options)

  print('User option =>', user_option)
  print('Computer option =>', computer_option)
  return user_option, computer_option

def check_rules(user_option, computer_option, user_wins, computer_wins):
  if user_option == computer_option:
    print('Empate!')
  elif user_option == 'piedra':
    if computer_option == 'tijera':
      print('piedra gana a tijera')
      print('user gano!')
      user_wins += 1
    else:
      print('Papel gana a piedra')
      print('computer gano!')
      computer_wins += 1
  elif user_option == 'papel':
    if computer_option == 'piedra':
      print('papel gana a piedra')
      print('user gano')
      user_wins += 1
    else:
      print('tijera gana a papel')
      print('computer gano!')
      computer_wins += 1
  elif user_option == 'tijera':
    if computer_option == 'papel':
      print('tijera gana a papel')
      print('user gano!')
      user_wins += 1
    else:
      print('piedra gana a tijera')
      print('computer gano!')
      computer_wins += 1
  return user_wins, computer_wins

def run_game():
  computer_wins = 0
  user_wins = 0  
  rounds = 1
  while True:
    print('*' * 10)
    print('ROUND', rounds)
    print('*' * 10)

    print('computer_wins', computer_wins)
    print('user_wins', user_wins)
    rounds += 1

    user_option, computer_option = choose_options()
    user_wins, computer_wins = check_rules(user_option, computer_option, user_wins, computer_wins)

    if computer_wins == 2:
      print('El ganador es la computadora')
      break

    if user_wins == 2:
      print('El ganador es el usuario')
      break

run_game()
```

### Test: Tienda de Tecnolog칤a
```python
def message_creator(text):
   # Escribe tu soluci칩n 游녢
   if text == "computadora":
      return "Con mi computadora puedo programar usando Python"
   elif text == "celular":
      return "En mi celular puedo aprender usando la app de Platzi"
   elif text == "cable":
      return "춰Hay un cable en mi bota!"
   else:
      return "Art칤culo no encontrado"

text = 'computadora'
response = message_creator(text)
print(response)
```
```
Con mi computadora puedo programar usando Python
```

## Funciones an칩nimas
<https://www.w3schools.com/python/python_lambda.asp>

Las funciones lambda en Python son funciones an칩nimas que se definen con la palabra clave lambda. Permiten crear funciones de manera m치s concisa y se utilizan principalmente para operaciones simples. La sintaxis es `lambda argumentos: expresi칩n`. Por ejemplo, `lambda x: x + 1` es una funci칩n que incrementa x en 1. Su uso es com칰n en funciones de orden superior, como `map()` y `filter()`, donde se necesitan funciones breves y sin nombre.

### Ejemplo
```python
def increment(x):
  return x + 1

increment_v2 = lambda x: x + 1

result = increment(10)
print(11)

result = increment_v2(20)
print(result)

full_name = lambda name, last_name: f'Full name is {name.title()} {last_name.title()}'

text = full_name('Rigoberto', 'Acosta Gonzalez')
print(text)
```
```
11
21
Full name is Rigoberto Acosta Gonzalez
```
## Funciones de orden superior (HOF)

Una HOF, o funci칩n de orden superior (Higher Order Function), es una funci칩n que puede recibir otras funciones como argumentos o devolver funciones como resultado. Este concepto es fundamental en Python, ya que permite una programaci칩n m치s flexible y din치mica. Por ejemplo, puedes tener una funci칩n que toma otra funci칩n (como `increment`) y un valor, aplicando esta funci칩n al valor recibido. Esto te permite crear funciones m치s abstractas y reutilizables, mejorando la organizaci칩n de tu c칩digo.

### Ejmplo
```python
def increment(x):
  return x + 1

increment_v2 = lambda x: x +1

def high_ord_func(x, func):
  return x + func(x)

high_ord_func_v2 = lambda x, func: x + func(x)

result = high_ord_func(2, increment)
# 2 + (2 + 1)
print(result)

result = high_ord_func_v2(2, increment_v2)
print(result)
result = high_ord_func_v2(2, lambda x: x + 2)
print(result)
## change
result = high_ord_func_v2(2, lambda x: x * 5)
print(result)
```
```
5
5
6
12
```
## Map Function
<https://www.w3schools.com/python/ref_func_map.asp>

La funci칩n `map` en Python es una higher-order function que permite transformar los elementos de una lista aplicando una funci칩n a cada uno de ellos. Retorna un iterable con el mismo n칰mero de elementos, pero con los resultados de la transformaci칩n. Puedes usarla con funciones definidas o funciones lambda para simplificar el c칩digo, permitiendo realizar la transformaci칩n en una sola l칤nea. Por ejemplo:
```python
numbers = [1, 2, 3]
result = list(map(lambda x: x * 2, numbers))
```
```
Devuelve [2, 4, 6]
```
Se puede usar tambi칠n con m칰ltiples listas, limit치ndose a la longitud de la lista m치s corta.

### Ejemplo

```python
numbers = [1, 2, 3, 4]
numbers_v2 = []
for i in numbers:
  numbers_v2.append(i * 2)

numbers_v3 = list(map(lambda i: i * 2, numbers))

print(numbers)
print(numbers_v2)
print(numbers_v3)

numbers_1 = [1, 2, 3, 4]
numbers_2 = [5, 6, 7]

print(numbers_1)
print(numbers_2)
result = list(map(lambda x, y: x + y, numbers_1, numbers_2))
print(result)
```
```
[1, 2, 3, 4]
[2, 4, 6, 8]
[2, 4, 6, 8]
[1, 2, 3, 4]
[5, 6, 7]
[6, 8, 10]
```

```python
items = [
  {
    'product': 'camisa',
    'price': 100,
  },
  {
    'product': 'pantalones',
    'price': 300
  },
  {
    'product': 'pantalones 2',
    'price': 200
  }
]

prices = list(map(lambda item: item['price'], items))
print(items)
print(prices)

def add_taxes(item):
  item['taxes'] = item['price'] * .19
  return item

new_items = list(map(add_taxes, items))
print(new_items)
print(items)
```
```
[{'product': 'camisa', 'price': 100}, {'product': 'pantalones', 'price': 300}, {'product': 'pantalones 2', 'price': 200}]
[100, 300, 200]
[{'product': 'camisa', 'price': 100, 'taxes': 19.0}, {'product': 'pantalones', 'price': 300, 'taxes': 57.0}, {'product': 'pantalones 2', 'price': 200, 'taxes': 38.0}]
[{'product': 'camisa', 'price': 100, 'taxes': 19.0}, {'product': 'pantalones', 'price': 300, 'taxes': 57.0}, {'product': 'pantalones 2', 'price': 200, 'taxes': 38.0}]
```
### Reto con map

El objetivo era crear una nueva lista a partir de un array original sin modificarlo. El problema surg칤a porque al modificar un diccionario dentro del `map`, se alteraba tambi칠n el array original debido a la referencia en memoria. La soluci칩n consisti칩 en utilizar la funci칩n `copy()` para crear una copia del diccionario antes de hacer cualquier modificaci칩n. Esto permiti칩 que el nuevo diccionario tuviera una referencia diferente, manteniendo intacto el array original.


```python
items = [
  {
    'product': 'camisa',
    'price': 100,
  },
  {
    'product': 'pantalones',
    'price': 300
  },
  {
    'product': 'pantalones 2',
    'price': 200
  }
]

def add_taxes(item):
  new_item = item.copy()
  new_item['taxes'] = new_item['price'] * .19
  return new_item

new_items = list(map(add_taxes, items))
print('New list')
print(new_items)
print('Old list')
print(items)
```
```
New list
[{'product': 'camisa', 'price': 100, 'taxes': 19.0}, {'product': 'pantalones', 'price': 300, 'taxes': 57.0}, {'product': 'pantalones 2', 'price': 200, 'taxes': 38.0}]
Old list
[{'product': 'camisa', 'price': 100}, {'product': 'pantalones', 'price': 300}, {'product': 'pantalones 2', 'price': 200}]
```
### Reto: Multiplica todos los elementos por dos

```python
def multiply_numbers(numbers):
    # Escribe tu soluci칩n 游녢
    return list(map(lambda x: x*2, numbers))

numbers = [1, 2, 3, 4]
response = multiply_numbers(numbers)
print(response)
```
```
[2, 4, 6, 8]
```
## Filter Function
<https://www.w3schools.com/python/ref_func_filter.asp>

La funci칩n `filter` en Python se utiliza para crear una nueva lista a partir de una lista existente, seleccionando solo aquellos elementos que cumplen con una condici칩n espec칤fica. Se aplica junto con una funci칩n, que puede ser una funci칩n `lambda`, que devuelve `True` o `False` para cada elemento. A diferencia de `map`, `filter` no transforma los elementos, sino que filtra seg칰n la condici칩n dada, y nunca devuelve m치s elementos de los que se estaban evaluando.

### Ejemplo
```python
numbers = [1,2,3,4,5]
new_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(new_numbers)
print(numbers)
```
```
[2, 4]
[1, 2, 3, 4, 5]
```

## Filter and Dict

> No hay problemas con la referencia de memoria.


```python
matches = [
  {
    'home_team': 'Bolivia',
    'away_team': 'Uruguay',
    'home_team_score': 3,
    'away_team_score': 1,
    'home_team_result': 'Win'
  },
  {
    'home_team': 'Brazil',
    'away_team': 'Mexico',
    'home_team_score': 1,
    'away_team_score': 1,
    'home_team_result': 'Draw'
  },
  {
    'home_team': 'Ecuador',
    'away_team': 'Venezuela',
    'home_team_score': 5,
    'away_team_score': 0,
    'home_team_result': 'Win'
  },
]

print(matches)
print(len(matches))

new_list = list(filter(lambda item: item['home_team_result'] == 'Win', matches))

print(new_list)
print(len(new_list))

print(matches)
print(len(matches))
```
```
[{'home_team': 'Bolivia', 'away_team': 'Uruguay', 'home_team_score': 3, 'away_team_score': 1, 'home_team_result': 'Win'}, {'home_team': 'Brazil', 'away_team': 'Mexico', 'home_team_score': 1, 'away_team_score': 1, 'home_team_result': 'Draw'}, {'home_team': 'Ecuador', 'away_team': 'Venezuela', 'home_team_score': 5, 'away_team_score': 0, 'home_team_result': 'Win'}]
3
[{'home_team': 'Bolivia', 'away_team': 'Uruguay', 'home_team_score': 3, 'away_team_score': 1, 'home_team_result': 'Win'}, {'home_team': 'Ecuador', 'away_team': 'Venezuela', 'home_team_score': 5, 'away_team_score': 0, 'home_team_result': 'Win'}]
2
[{'home_team': 'Bolivia', 'away_team': 'Uruguay', 'home_team_score': 3, 'away_team_score': 1, 'home_team_result': 'Win'}, {'home_team': 'Brazil', 'away_team': 'Mexico', 'home_team_score': 1, 'away_team_score': 1, 'home_team_result': 'Draw'}, {'home_team': 'Ecuador', 'away_team': 'Venezuela', 'home_team_score': 5, 'away_team_score': 0, 'home_team_result': 'Win'}]
3
```
### Reto: Retorna solo palabras de 4 letras y m치s

```python
def filter_by_length(words):
   # Escribe tu soluci칩n 游녢
   return list(filter(lambda x: len(x)>=4, words))

words = ['amor', 'sol', 'piedra', 'd칤a']
response = filter_by_length(words)
print(response)
```
```
['amor', 'piedra']
```
## Reduce Function
La funci칩n `reduce` en Python, proveniente del m칩dulo `functools`, se utiliza para aplicar una funci칩n de manera acumulativa a los elementos de una lista, reduci칠ndola a un solo valor. Toma dos argumentos: una funci칩n y una lista.
Por ejemplo, para sumar todos los elementos de una lista, `reduce` inicia con el primer elemento y lo acumula aplicando la funci칩n al siguiente elemento. Este proceso contin칰a hasta que se itera sobre toda la lista, resultando en un 칰nico valor, como la suma total.

### Ejemplo de uso
```python
from functools import reduce

numeros = [1, 2, 3, 4]
resultado = reduce(lambda x, y: x + y, numeros)
print(resultado)
```
```
10
```
Esto demuestra c칩mo reduce simplifica operaciones como la suma, max, etc.


# M칩dulos

# Manipulaci칩n de archivos y errores

# Gr치ficas en Python

# Next



