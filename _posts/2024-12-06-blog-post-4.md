---
title: 'Introducci√≥n a la Terminal y L√≠nea de Comandos'
date: 2024-12-06
permalink: /posts/2024/12/blog-notes-4/
tags:
  - cool posts
  - category1
  - category2
  - platzi
---

Tutorial introductorio a la Terminal y L√≠nea de Comandos.

Si alguna vez viste una pel√≠cula de hackers, seguro has visto la ventana negra que abren en sus computadores, d√≥nde escriben muchas letras sin sentido. Esto se conoce como terminal, pero, te lo explicaremos m√°s a detalle. 

# Intro

La terminal es un programa que ejecuta l√≠neas de comandos, que a su vez estas l√≠neas de comando ejecutan acciones y aqu√≠ tienes que aprender dos conceptos: terminal y shell.

## Terminal

Estamos muy acostumbrados a que en nuestra computadora inicie un sistema operativo que tenga un sistema de ventanas en el que podemos abrir carpetas y programas y podamos mover archivos a trav√©s de una interfaz gr√°fica. La terminal es otra ventana m√°s, es un programa, una interfaz que recibe un comando para luego pas√°rselo a la shell y que esta √∫ltima la ejecute. Con este programa podemos hacer todo lo que el sistema de carpetas e interfaz gr√°fica del sistema operativo puede hacer, pero utilizando comandos.

## Shell

Ahora la terminal no ejecuta l√≠neas de c√≥digo, solo la recibe, es la shell quien hace todo el proceso de tomar el comando, ir con el procesador y la memoria RAM y decirles "tomen, ejecuten esto". Si lo pensamos de otra forma, la shell nos proporciona una forma de comunicarnos con el procesador y la RAM sin tener que pasar por la interfaz gr√°fica

## Comando

Un programa que se puede ejecutar desde la terminal. Este puede recibir par√°metros y opciones. 

### ¬øQu√© es un comando?

1. Un programa ejecutable.
2. Un comando de utilidad de la shell.
3. Una funci√≥n de shell.
4. Un alias.

Ejemplos de comandos b√°sicos de la terminal
Ahora conocer√°s varios tipos de comandos que puedes aplicar en el proyecto que est√°s realizando.

- `type` <comando>: Nos permite conocer qu√© tipo de comando es ü§î.
- `alias l="<secuencia de comandos>"`: Nos permite crear comandos. Son temporales, se borran al cerrar la terminal üë∂üèº.
- `help` <comando>: Nos permite consultar un poco de documentaci√≥n de un comando üìÑ.
- `man` <comando>: De manual, nos permite conocer mucha m√°s informaci√≥n de un comando.
- `info` <comando>: Similar al anterior, pero un poco resumido y con otro formato.
- `whatis` <comando>: Describe un comando en una sola l√≠nea ‚ò∫Ô∏è. No funciona con todos.

[41 comandos de la terminal que debes conocer](https://platzi.com/blog/41-comandos-terminal/)

# Primeros pasos

## Sistema de Archivos

![image_1](/images/terminal/file_system.png)

> Adicional: <https://www.geeksforgeeks.org/linux-file-hierarchy-structure/>

La carpeta con el s√≠mbolo `"/"` es la ra√≠z, ah√≠ es donde comienza todo el sistema de ficheros (el equivalente en Windows podr√≠a ser el fichero `"C:\"`). Dentro de esta carpeta hay varios ficheros, el que nos importa en este momento es el "Home".

La carpeta "Home" contiene una carpeta por cada usuario del sistema y ya dentro de cada una de estas carpetas, estar√°n las carpetas que conocemos de toda la vida como im√°genes, documentos, m√∫sica, etc.

### Atajos

- Virgulilla (`~`): indica la carpeta del usuario en el home.

- Punto y doble punto (`.`) (`..`): No siempre quieres ir hacia adelante, a veces necesitas devolverte, para eso utilizas el atajo del doble punto (`..`) que te env√≠a a la carpeta que est√° atr√°s. Por otro lado, el punto (`.`) √≠ndica la carpeta actual, as√≠ puedes hacer direcciones m√°s precisas.

### Comando `ls`

Este comando lista los archivos y carpetas dentro del directorio que selecciones.

Para saber informaci√≥n adicional como la fecha de creaci√≥n, el peso, los permisos, etc., utilizamos la opci√≥n `-l` que significa `Long`.

Lo anterior nos muestra una tabla que tiene mucha informaci√≥n, pero c√©ntrate en la columna que son el peso, pero el peso en bytes, lo cual lo hace un poco complicado de leer. Podemos a√±adir la opci√≥n `-h` que significa `Human Readable`.

El comando `ls -lS` ordena por peso los archivos y carpetas.


> Nota: para a√±adir m√°s de una opci√≥n no hacemos esto `ls -l -h` sino esto `ls -lh`.

### Resumen de Comandos

Comando | Funci√≥n | 
| --- | --- | 
| pwd | Print Working Directory: Muestra en la carpeta en la que estas | 
| cd | Change Directory: Te mueve a la carpeta que desees | 
| ls | List: Lista los archivos y carpetas dentro del directorio que selecciones | 
| file | Muestra la informaci√≥n del archivo que selecciones |

## Manipulando archivos y directorios


| Comando | Funci√≥n | 
| --- | --- | 
| mkdir | Crea carpetas | 
| touch | Crea archivos | 
| cp | Copia archivos | 
| mv | Mueve archivos | 
| rm | Elimina archivos o carpetas |

- Para copiar un archivo usando la terminal solo debes escribir el comando `cp` (`cp` es de Copy) seguido del nombre del archivo que deseas copiar y, por √∫ltimo, el nombre con el que quieres que se guarde la copia.

- La sintaxis para el comando `mv` (`mv` es de Move) es igual que la del comando `cp`. Primero el nombre del archivo que quieres mover y luego a donde se va a mover.

- Para eliminara, solo debes escribir el nombre o la ruta del elemento que quieres eliminar y delante del comando `rm` (`rm` es de Remove). El comando `rm` tiene varias opciones. Las m√°s usadas son: 
  - `-i` (de interactive) te pregunta si est√°s seguro de eliminar el archivo 
  - `-r` (de recursive) elimina todo lo que est√© dentro de una carpeta 
  - `-f` (de force) fuerza a borrar todo. (La opci√≥n `-f` se usa cuando no puedes borrar alg√∫n archivo, bien sea porque algo lo est√° usando o porque se est√° ejecutando.)

## Explorando el contenido de nuestros archivos

| Comando | Funci√≥n | 
| --- | --- | 
| head | Muestra las primeras 10 l√≠neas | 
| tail | Muestra las √∫ltimas 10 l√≠neas | 
| less | Muestra todo el contenido dentro de la consola | 
| xdg-open | Abre un programa para inspeccionar ese archivo | 
| nautilus | Abre en la interfaz de ventanas la carpeta que selecciones |

En espa√±ol, cabeza y cola tienen una funcionalidad muy sencilla, `head` imprime las primeras 10 l√≠neas de un archivo y `tail` imprime las 10 √∫ltimas l√≠neas.Si no quieres ver las primeras l√≠neas, sino que quieres ver las primeras 20, por ejemplo, entonces usas la opci√≥n `-n` seguida del n√∫mero de l√≠neas que quieres ver.

- Para observar todo el contenido de un archivo, escribes el nombre del archivo que quieres abrir y delante del comando `less`. Ahora tendr√°s una especie de interfaz gr√°fica donde podr√°s inspeccionar el documento. Puedes usar las flechas y el scroll para moverte arriba y abajo. Adem√°s, puedes buscar palabras dentro del documento. Si presionas la tecla slash `"/"`, en la parte de abajo se habilitar√° un cuadro donde podr√°s buscar palabras, solo escribe y presiona `enter`. Para salir de la interfaz presiona `"q"`.

- Abrir en un programa el archivo podemos emplear el comando `xdg-open` es sencillo porque hace algo muy simple, abre el archivo que desees en el programa predeterminado para su extensi√≥n. 

- Pues como todo programa lo podemos ejecutar desde la consola usando el comando `nautilus` se usa igual que `xdg-open`, solo que debes seleccionar una carpeta.

## Alias

Ahora, podemos crear nuestro propio comando con un alias llamado `l`:

```shell
alias l="ls -lh"
```

Pero si cerramos y volvemos a abrir la terminal, este alias se pierde. Existen formas de almacenar todos los alias creados.

## Wildcards

Las wildcards o comodines son una serie de caracteres especiales que nos permiten encontrar patrones o realizar b√∫squedas m√°s avanzadas. Es aplicable para archivos y directorios.

Las wildcards te sirven para realizar seccionamiento de archivos o directorios, adem√°s de `ls` los wildcards tambien pueden usarse con cualquier comando que realice la manipulaci√≥n de archivos como `mv`, `cp` y `rm`.

### Tipos de wildcards

| Wildcard | Funci√≥n | 
| --- | --- | 
| * | Busca todo | 
| ? | Busca por cantidad de caracteres | 
| [] | Busca por caracteres espec√≠ficos |


- **Buscar todo (*):** el asterisco te ayuda a buscar toda la informaci√≥n dentro de una carpeta, pero puedes limitar su uso. Si por ejemplo quieres buscar los archivos que tengan una extensi√≥n ".png", escribes: `ls -l *.png`. 
  - Tambi√©n lo puedes poner al final, si quisieras buscar, todos los archivos que comiencen por unos caracteres espec√≠ficos, entonces escribes esos caracteres y luego el asterisco. Por ejemplo, si quisieras buscar todos los archivos que comiencen por `"fotosDe"`, habr√≠a que escribir: `ls -l fotoDe*`

- **Buscar por cantidad de caracteres (?):** si dentro de tus archivos tuvieras una especie de c√≥digo para guardar tus fotos, algo as√≠ como "foto1.png", "foto2.png", "foto3.png", etc. En este caso, sabemos que primero tenemos el string "foto", luego un solo n√∫mero y por √∫ltimo la extensi√≥n ".png". Si quisieras buscar esas fotos escribir√≠as: `ls -l foto?.png`.
  - Pero si sabes que no tiene un solo caracter, sino que tiene varios, entonces escribes tantos signos de interrogaci√≥n como caracteres existan. Por ejemplo, si quieres buscar las fotos que tengan esta estructura "foto11.jpg", escribes: `ls -l foto??.jpg`

- Tambi√©n puedes combinar wildcards. Por ejemplo, si sabes que tus fotos siguen esta especie de c√≥digo, pero no sabes que extensi√≥n tienen, escribes: `ls -l foto?.*`

- **Buscar por caracteres espec√≠ficos ([]):** si quieres buscar por varios caracteres espec√≠ficos se usan corchetes. Para utilizarlos tienes que colocar dentro de los corchetes los caracteres que quieres buscar.Por ejemplo, si quisieras buscar los archivos que comiencen por las letras "c" o "i", entonces escribes: `ls -l [ci]*`
  - Cuando buscamos con esta wildcard ten en cuenta que es case sensitive, por lo que la letra "i" no es lo mismo que la letra "I". `ls -l [cCiI]*`
  - Si quieres buscar por rango de n√∫meros tambi√©n tienes que usar esta wildcard. Para hacerlo, escribe el rango de n√∫meros que quieres buscar separados por un guion. `ls -l foto[2-6]*`
  - Con el siguiente comando buscamos directorios que comiennce con may√∫sculas `ls -d [[:upper:]]*` 
  - Para buscar por n√∫meros se puede usar: `ls [[:alnum:]]*` o `ls [[:digit:]]*`
    - Clases dentro de los Wildcards:
      - `[:alnum:]` Coincide con cualquier car√°cter alfanum√©rico
      - `[:alpha:]` Coincide con cualquier car√°cter alfab√©tico
      - `[:digit:]` Coincide con cualquier n√∫mero
      - `[:lower:]` Coincide con cualquier letra min√∫scula
      - `[:upper:]` Coincide con cualquier letra may√∫scula

### Truco

Si quieren que el alias permanezca en la terminal y no se pierda cuando la cierren pueden guardar los alias al final del archivo que se encuentra en el `home` de cada pc llamado en el caso de bash es `~/.bashrc` y despu√©s de guardarlo le das el comando `source ~/.bashrc` para que se apliquen los cambios.

# Empezando a correr

## Redirecciones

¬øQu√© son las entradas y salidas de la terminal?

En la consola nosotros generamos una entrada cuando escribimos y una salida casi siempre que ejecutamos un comando. A las entradas t√≠picamente se les suele llamar `Standard Input` y a las salidas `Standard Output`, adem√°s se les suele abreviar como `stdin` y `stdout` respectivamente.

Los **file descriptors** son n√∫meros que identifican un recurso. Funciona asociando un n√∫mero con una acci√≥n, archivo o programa, en el caso de la shell tenemos 3 file descriptors:

0. stdin
1. stdout
2. stderr (Standard Error)

| Operador | Funci√≥n | 
| --- | --- | 
| > | Redirecciona la salida. Por defecto redirecciona el Standar Output |
| < | Redirecciona la entrada a alg√∫n comando. Es algo raro este uso |
| >> | Concatena la salida con lo que ya tenga el archivo a donde se est√° redirigiendo la salida | 
| 2> | Redirecciona el file descriptor 2 (En este caso Standar Error) | 
| 2>&1 | Redirecciona el file descriptor 2 y 1 |

Si queremos guardar la informaci√≥n de una salida porque nos puede interesar almacenar lo que esa salida contiene. Veamos el siguiente ejemplo, si utilizas el comando: `ls -l`. Si quieres que el `Standard Output` no vaya a la consola sino hacia un archivo, entonces puedes usar el operador `>` seguido del nombre del archivo en el que quieres guardar la salida. `ls -l > output.txt`

Si se tiene el archivo `output.txt` y ahora tambi√©n quieres guardar la informaci√≥n de la carpeta de documentos, entonces no puedes volver a ejecutar: `ls -l > output.txt`, esto lo que har√° es reescribir el contenido del documento, lo que necesitas es **concatenar** el contenido del documento con el de la salida, para eso ejecutas: `ls -l >> output.txt`.

El operador de redirecci√≥n por defecto solo redirecciona el file descriptor 1 (es decir, el `Standard Output`). Vamos a generar un error ejecutando un comando que saldr√° mal para redirigirlo a un archivo llamado "error.txt". `ls -l√± 2> error.txt`

Tambi√©n podemos especificar que no importa lo que pase si me da un Standar Ouput o un Standar Error, igual tiene que guardar la salida en un archivo. Esto lo hacemos as√≠: `ls -l > output.txt 2>&1`. La orden `2>&1` significa que debe redirigir el file descriptor 2 y el file descriptor 1.

## Pipe operator

**Pipe operator** es un operador que permite tomar la salida de un comando y pasarla como entrada de otro comando. 

| Comando | Funci√≥n | 
| --- | --- | 
| sort | Organiza allfab√©ticamente una salida | 
| cat | Concatena dos entradas | 
| tee | Crea un archivo en base a una entrada |

- Si queremos crear una lista de los archivos de varias carpetas, podemos usar `cat` para concatenar la salida de varios de ellos. 
  - `ls ./Downloads > descargas.txt` `ls ./Documents > documentos.txt` `cat descargas.txt documentos.txt`

- Si queremos guardar la lista creada anteriormente, podemos pasar esa salida por medio de un pipe operator al comando `tee`, el cual crear√° un archivo con esa salida.
  - `cat descargas.txt documentos.txt | tee archivos.txt`

- Puede ser algo complicado encontrar un archivo dentro de la lista, por lo que lo podemos organizar alfab√©ticamente una salida con el comando `sort`.
  - `ls | sort | tee archivosHome.txt`

- Ver mi directorio y salvarlo en un arhivo:
  - `ls -lh | tee output.txt | less`
  - Aplicando filtro sort `ls -lh | sort | tee output.txt | less`

### Comandos nerd

- `cowsay`
  1. Install: `sudo apt install cowsay`
  2. cowsay "mensaje"

- `lolcat`
  1. Install: `sudo apt install lolcat`
  2. echo "mensaje" | lolcat

- Uso curioso `cowsay "mensaje" | tee vaca.txt | lolcat`

## Encadenando comandos: operadores de control

 Operador | Funci√≥n | 
 | --- | --- | 
 | ; | Ejecuta de forma s√≠ncrona los comandos espec√≠ficados | 
 | & | Ejecuta de forma as√≠ncrona los comandos espec√≠ficados | 
 | && | Ejecuta el comando si el anterior se ejecut√≥ correctamente | 
 | \|\| | Ejecuta el comando si el anterior o la combinaci√≥n de los anteriores resultaron en verdadero |


| Comando | Funci√≥n | 
| --- | --- | 
| echo | Imprime el mensaje que le indiques | 
| cal | De calendar imprime un calendario con la fecha actual | 
| date | Imprime la fecha actual |

Los operadores de control son s√≠mbolos reservados por la terminal que nos permiten encadenar comandos. Si usas constantemente la tecla enter para ejecutar varios comandos, puedes evitarlo si usas el `operador ;` que separa los comandos que estamos ejecutando.

- **Comandos en la misma l√≠nea (;):** Solo necesitas escribir los comandos que quieres ejecutar separados por `;` y luego presionar `enter`.`mkdir ProyectosSecretos; ls; date`

- **Comandos as√≠ncronos (&):** Cuando queremos ser m√°s eficientes podemos ejecutar varios comandos al mismo tiempo, de modo que no tenemos que esperar a que uno se ejecute para luego ejecutar el que sigue. Para llevar a cabo varios comandos, al mismo tiempo, usamos el `operador &` entre cada comando que queremos ejecutar. `date & echo "Hola" & cal`

- **Comandos con condicionales**:
  - **Condici√≥n and (&&):** estamos indicando que para que estos se ejecuten, el comando anterior tuvo que ejecutarse correctamente. `cd lp && mkdir Comida`
  - **Condicional or (||):** Al condicional or no le importa si el comando anterior se ejecut√≥ o no, simplemente va probando todos los comandos a ver cu√°l se ejecuta. `cd ProyectosSecretos/ || cambia-carpeta ProyectosSecretos/`
  - **Combinando operadores de control:** `cd ProyectosSecretos/ || cambia-carpeta ProyectosSecretos/ && mkdir ProyectoIncreible`

## C√≥mo se manejan los permisos

> Se pueden representar los permisos de forma octal. <https://platzi.com/tutoriales/1667-linux/8811-cosas-que-nos-sabias-sobre-el-sistema-de-permisos-de-linux-realmente-es-octal/>

Los permisos son las capacidades que tiene cada usuario dentro del sistema operativo, no todos los usuarios pueden hacer todas las acciones sobre ciertos archivos y carpetas.

### Tipo de archivo

| Atributo | Tipo de archivo | 
| --- | --- | 
| - | Es un archivo normal, como un documento de texto, una foto, un video, etc. | 
| d | Por directory es un directorio | 
| l | Es un enlace simb√≥lico. Es algo que veremos en pr√≥ximas clases | 
| b | Bloque especial, son archivos que manejan informaci√≥n para el sistema, como la informaci√≥n de un disco duro |

### Permisos de usuario

- Owner: El due√±o del archivo, si no se ha cambiado, es quien lo creo y tiene mayor jerarqu√≠a sobre los otros 3. Le corresponden los primeros 3 caracteres de los permisos.
- Group: Se puede crear grupos de usuarios para darle a todos o varios los mismos permisos. A estos usuarios le corresponden el cuarto, quinto y sexto caracter de los permisos de usuarios y tienen mayor jerarqu√≠a que el √∫ltimo.
- World: Tambi√©n llamado "otros", es cualquier otro usuario que no pertenezca a un grupo de usuario y tampoco sea el due√±o, este tiene la menor jerarqu√≠a.

### Tipos de permisos

| S√≠mbolo | Significado | Permiso | 
| --- | --- | --- | 
| r | readable | Significa que puede leer su contenido | 
| w | writable | El usuario puede editar el contenido del archivo, tambi√©n el nombre y los permisos | 
| x | executable | El usuario puede ejecutarlo en caso de que sea un programa |

Los permisos se escriben en ese orden `rwx`. Para indicar que el permiso no est√° disponible, se escribe un guion.

#### Ejemplo

Observa el siguiente grupo de permisos: `drwxr-xr-x`.

Recuerda que el primer caracter es el tipo y los siguientes se cuentan de 3 en 3 representando cada usuario.

| d | rwx | r-x | r-x | 
| --- | --- | --- | --- | 
| Esto es un directorio | owner | group | world | 
|| El due√±o puede leer, escribir y ejecutar | El grupo puede leer y ejecutar | Los dem√°s pueden leer y ejecutar |

Vamos con otro

`-rw-r--r--`

| - | rw- | r-- | r-- | 
| --- | --- | --- | --- | 
| Esto es un archivo normal, como una im√°gen o un video | owner | group | world | 
| | El due√±o puede leer y escribir | El grupo s√≥lo puede leer | El resto s√≥lo puede leer |


### Pr√°ctica

Este concepto puede ser algo complicado as√≠ que lo mejor es pr√°cticar, te dejar√© unos ejercicios para que sea m√°s f√°cil interpretarlo.

Convierte los siguientes permisos a s√≠mbolos y en su representaci√≥n num√©rica:

1. De un directorio, el due√±o tiene permiso de lectura y escritura, el grupo tiene permisos de escritura y ejecuci√≥n y world no tiene permisos.
2. De un enlace simb√≥lico, el due√±o tiene todos los permisos, el grupo y world s√≥lo de lectura.
3. De un archivo com√∫n, todos tienen todos los permisos, pero el world no tiene permiso de ejecuci√≥n.

> Crear enlace s√≠mbolico: `ln -s [ruta/del/archivo/original] [ruta/del/enlace/simbolico]`

## Modificando permisos en la terminal

| owner | group | others | 
| --- | --- | --- | 
| u (de user) | g | o |


| Operador | Funci√≥n | 
| --- | --- | 
| + | A√±ade un permiso | 
| - | Quita un permiso | 
| = | Asigna un permiso |

`chmod [simboloDelUsuario][operador][permiso] [archivoParaCambiarSusPermisos]`

Supongamos que queremos a√±adirle permiso de escritura al grupo, entonces tenemos que escribir lo siguiente: `chmod g+w file_test.txt`

Puedes cambiar varios permisos de varios usuarios al mismo tiempo, por ejemplo, si quisieras agregar el permiso de escritura y ejecuci√≥n al grupo y a otros, ser√≠a as√≠: `chmod go+wx [archivo]`

Y si quieres permisos diferentes para cada usuario, solo sep√°ralos por comas: `chmod u+r,g=w [archivo]`

> Tambi√©n puedes cambiar los permisos usando su forma octal.

### Gestionar usuarios `(whoami | su)`

El comnando `whoami`, literalmente "¬øQuien soy yo?", te muestra cual es el usuario que se est√° ejecutando, esto es porque a veces podemos olvidar con cual usuario estamos trabajando.

Para cambiar de usuario se usa el comando su Switch User, seguido del usuario al que quieres cambiar, en este caso vamos a cambiar al superusuario root. `su root`

> **Cuidado:** el superusuario `root` (s√≠, ese es el nombre t√©cnico) tiene poder para hacer y deshacer con el sistema operativo, puedes eliminar cosas que no deber√≠as eliminar y puede hacer mucho desastre. Usa los privilegios del `root` con cuidado.

### Cambiar el propietario (chown)

Puede que no te quieras hacer responsable de tus archivos, as√≠ que se los quieres dejar a alguien m√°s. Para eso usa el comando `chown` Change Owner. La sintaxis es muy simple: `chown [usuarioAlQuePertenecer√°] [archivo]`

| Comando | Funci√≥n | 
| --- | --- | 
| whoami | Muesta el usuario con el que se est√° trabajando | 
| su | Switch User Cambia al usuario al que le especifiques | 
| chmod | Cambia los permisos de un archivo | 
| chown | Change Owner Cambia el propietario de un archivo |

#### Pr√°ctica

Recuerda que si haces mucho desastre puedes borrar casi lo que sea con el usuario root y ten mucho cuidado con lo que borras.

1. Crea un archivo llamado "ArchivoPoderoso.txt", luego dale los permisos r-xrwxr-xr-x usando la forma simb√≥lica del comando chmod.
2. Crea un archivo con el usuario root llamado "pelota.txt", luego dale los permisos rwxr-x--x usando la forma num√©rica del comando chmod y luego cambia el propietario a tu usuario principal con chown.
3. Crea un archivo con un nombre bonito y as√≠gnale los permisos --------- usando su forma simb√≥lica.

## C√≥mo configurar variables de entorno

Las variables de entorno son √∫tiles cuando necesitamos que cierta informaci√≥n prevalezca para poder trabajar m√°s r√°pido o necesitamos guardar informaci√≥n para no tener que recordarla constantemente.

| Variable | Contenido | 
| --- | --- | 
| HOME | Indica el home del usuario | 
| PATH | Indica las direcciones de donde est√°n los binarios que usa el sistema | 
| BASH_VERSION | Indica la versi√≥n del bash que est√°s utilizando | 
| SHELL | Direcci√≥n de la shell que est√°s utilizando |

`echo $HOME`

> Por convenci√≥n las variables de entorno se crean en may√∫sculas.

## ¬øC√≥mo crear tus propias variables de entorno?

En el home de tu usuario debe haber un archivo oculto llamado `".bashrc"`, lo puedes ver ejecutando el comando `ls -la` la opci√≥n `-a` es de all. `ls -la`

> Pero se puede hacer mejor porque tambi√©n puedo crear un `alias` que no se borre cuando cierre la terminal.

> Nunca crees alias de comandos que ya existe, carece de l√≥gica.

### WSL

Desde WSL, podemos abrir `.bashrc` utilizando el comando `code .bashrc`, si tienes instalado `VS Code` esto te mostrar√° el documento en el editor. Si est√°s en WSL y no te funciona, ve a la `cmd`, ejecuta el comando `wsl` y vu√©lvelo a intentar desde ah√≠.

Vamos a crear una variable de entorno que me de la ruta de mi carpeta en Windows sin que tenga que escribir toda la ruta.

`WINDOWS="/mnt/c/users/user_test/`

Ahora guardo el archivo, reinicio la terminal y ejecuto:

`cd $WINDOWS`

## Comandos de b√∫squeda

A veces necesitas localizar varios archivos del mismo tipo que ocupan espacio innecesario en tu disco duro.

Por ejemplo, algunos programas que funcionan desde la consola, como npm, guardan sus errores en archivos de extensi√≥n ".log" y si no est√°s pendiente de eliminarlos se van acumulando en tu disco duro.

- Para encontrar archivos de forma efectiva, usa el comando `find`, el cual buscar√° en la ruta que le indiques el tipo de archivos que necesitas. Su sintaxis es: `find [rutaDesdeDondeEmpezarBuscar] [opciones]`
  - Segmentar por el nombre (`-name`): `find ./ -name *.png`
  - Segmentar por el tipo (`-type`): la opci√≥n `-type`, el cual acepta `f` para archivos, `d` para directorios y `l` para enlaces simb√≥licos: `find ./ -type f -name "f*"`
    - Veamos un ejemplo buscando archivos y directorios: `find ./ -type f,d -name "D*"`
  - Segmentar por tama√±o (`-size`): hay que colocar la unidad de peso **c** para byte, **k** para Kilobyte, **M** para Megabyte y **G** para Gygabyte. `find ./ -size +4k`
  - Buscar vac√≠os (`-empty`): `find ./ -type d -empty`
  - Limitar la b√∫squeda (`-maxdepth` `-mindepth`): `find ./ -type d -maxdepth 2` 
  - Una √∫ltima cosa, es recomendable pasar el output al comando `less`, as√≠: `find ./ | less`

| Opci√≥n | Funci√≥n | 
| --- | --- | 
| -size | Busca por el peso | 
| -mindepth | Asigna una profundidad m√≠nima | 
| -maxdepth | Asigna una profundidad m√°xima | 
| -type | Busca por el tipo de archivo | 
| -name | Busca por el nombre del archivo |

### Pr√°ctica

El abito hace al monje y la terminal al buen programador.

Crea el comando `find` para cada uno de estos casos: 
1. Busca tus archivos mayores a 100Mb, con una profundidad m√°xima de 4, que comiencen por la letra d. 
2. Busca los archivos que tengan extensi√≥n ".pdf" con una profundidad m√≠nima de 2. 
3. Busca todas las carpetas que comiencen por la letra "A" con una profundidad m√°xima de 5, que est√©n vac√≠as. 
4. Busca todo lo que tenga una letra "j" que pese m√°s de 1b. Luego guarda la salida en un archivo llamado "LosArchivosJ.txt" y cuando termine de hacer todo eso imprime un mensaje que diga "Comando terminado con √©xito".

---
Algunos los tuve que modificar debido a la ausencia de resultado para comprobar

1. `find ~/Documents/ -maxdepth 4 -type f -name 'a*' -size +10M | tee test1.txt && echo "End test 1"`
```
/home/riacosta/Documents/Science Books/Robotica/automatizacion-robotica.pdf
/home/riacosta/Documents/Science Books/0_Inbox/arm-designing-embedded-system-application-cortex-m.pdf
End test 1
```
2. `find . -mindepth 2 -type f -name '*.pdf' | tee test2.txt && echo "End Test 2"`
`head test2.txt`
```
./Desktop/Informatic_2024.pdf
./Desktop/BertJanssen-RelatividadGeneral.pdf
./Desktop/Algebra_Lineal_Aplicada.pdf
./Desktop/ON THE ELECTRODYNAMICS OF MOVING_Einstein_1905.pdf
./Desktop/Hola/Turno_1.pdf
./Desktop/precaria_2756339.pdf
./Desktop/Nota_Integral.pdf
./Desktop/PhD_thesis_FINAL_241205_145223.pdf
./Desktop/Sum_of_Odd_Cubes.pdf
./Desktop/Sums of Reciprocals of Binomial Coefficients.pdf
```
3. `find . -maxdepth 5 -type d -empty -name 'A*'`

4. `find . -type f -name 'j*.txt' -size +1c > LosArchivosJ.txt && echo "Comando terminado con exito"`
`head LosArchivosJ.txt`
```
./env_phd/lib/python3.10/site-packages/scipy/io/matlab/tests/data/japanese_utf8.txt
./Documents/Programming/Platzi/env_eda/lib/python3.10/site-packages/scipy/io/matlab/tests/data/japanese_utf8.txt
./Documents/Programming/Platzi/env_platzi/lib/python3.10/site-packages/scipy/io/matlab/tests/data/japanese_utf8.txt
./STM32Cube/Repository/STM32Cube_FW_F4_V1.28.1/Middlewares/Third_Party/LibJPEG/jconfig.txt
./STM32Cube/Repository/STM32Cube_FW_F4_V1.28.1/Middlewares/Third_Party/LibJPEG/jdosaobj.txt
```

<https://linuxhint.com/differences_between_bash_zsh/>

## Usando el comando grep

| Opci√≥n | Funci√≥n | 
| --- | --- | 
| -m | Limita las l√≠neas de la b√∫squeda | 
| -c | Cuenta las ocurrencias | 
| -v | Excluye las ocurrencias | 
| -i | Ignora √©l case sensitive |

Buscar texto dentro de un archivo con el comando `grep`. "Grep" significa Global Regular Expression Print. El comando `grep` utiliza regex (Regular Expression) para realizar su b√∫squeda, si no sabes como armar un regex aqu√≠ tienes el Curso de Expresiones Regulares

`grep [Expresi√≥nRegular] [archivoDondeBuscar]`

- Buscar la palabra `the` en el archivo: `grep the movies.csv`
- Ignorar case sensitive (-i): `grep -i Action movies.csv`, buscar√° independientemente de si la letra "A" es may√∫scula o min√∫scula.
- Contar ocurrencias (-c): `grep -c Drama movies.csv`, si quieres saber cu√°ntas veces se repite una palabra.
- Excluir una expresi√≥n (-v): `grep -cv Drama movies.csv`, saber cu√°les son los resultados que NO coinciden con tu expresi√≥n regular. Queremos contar todas las pel√≠culas que no son de drama.
- Limitar la b√∫squeda (-m): `grep -m 10 Fan movies.csv`, queremos buscar las primeras 10 l√≠neas que concuerden con la palabra `"Fan"`.


> Archivo empleado: [movies.csv](/files/movies.csv)

### Comando **nerd**

El comando `wc` (word count) se utiliza en la terminal para contar l√≠neas, palabras y caracteres en archivos de texto. Al ejecutar wc, puedes usar opciones como `-l` para contar l√≠neas, `-w` para contar palabras y `-c` para contar caracteres. 

Por ejemplo, `wc -l archivo.txt` mostrar√° el n√∫mero de l√≠neas en "archivo.txt". Este comando es √∫til para obtener r√°pidamente estad√≠sticas sobre el contenido de archivos y resulta complementario al uso de grep para filtrar y buscar informaci√≥n espec√≠fica dentro de textos.

# Utilidades de la terminal

## Red

| Comando | Funci√≥n | 
| --- | --- | 
| ifconfig | Muestra la configuraci√≥n de los dispositivos de red | 
| ping | Env√≠a paquetes a una direcci√≥n para comprobar su conectividad | 
| curl | Muestra por consola el archivo devuelto por la direcci√≥n | 
| wget | Guarda el archivo devuelto por la direcci√≥n |

El manejo de redes es bastante amplio, de hecho, es toda una rama de la inform√°tica. Aqu√≠ aprender√°s comandos b√°sicos de utilidades de la red para que puedas obtener la informaci√≥n que necesites.

- Configuraci√≥n de tus dispositivos `ifconfig`
- Enviar solicitudes a una p√°gina `ping`
  - Para limitar la cantidad de paquetes que enviamos, usamos la opci√≥n `-c` seguida del n√∫mero de paquetes por enviar. `ping -c 4 www.google.com`
  - Para probar la conectividad con paquetes de diferentes tama√±os se utiliza la opci√≥n `-s` seguido del tama√±o del paquete que desees usar. El tama√±o debe ser en bytes. `ping -s 20 www.google.com`
- Podemos obtener archivos que nos proporcione un sitio web o direcci√≥n IP con el comando `curl`. Este te mostrar√° la informaci√≥n que haya encontrado en la consola. `curl www.google.com`
- El comando `wget` hace algo similar, solo que en vez de mostrar lo que h obtenido por consola lo guarda en el archivo que le especifiques. `wget www.google.com` 
  - Tambi√©n podemos espec√≠ficar varias direcciones para descargar varias p√°ginas al mismo tiempo. `wget www.google.com www.platzi.com`
- Cuando nos conectamos a una p√°gina en internet no nos conectamos directamente a los servidores en los que est√° almacenada esa p√°gina, sino que primero pasamos por otros servidores que son como intermediarios entre tu computadora y el servidor.`traceroute`
- Mostrar dispositivos de red `netstat -i`.

## Comprimir archivos

Para comprimir con este formato en la terminal usamos el comando `tar` que tiene ciertas opciones para aprender.

`tar [opciones] [nombreDelArchivoComprimido] [archivoAComprimir]`

- Para comprimir un archivo utilizamos la opci√≥n `-c`. En todos los casos hay que usar la opci√≥n `-f` para indicar que estamos comprimiendo o descomprimiendo archivos. `tar -cf compressed.tar Documents/toCompress/`
- Si queremos ver lo que el comando est√° comprimiendo a medida que se va ejecutando, usamos la opci√≥n `-v`. Por cierto la opci√≥n `-v` es de "Verbose" y muchos comandos la usan, tambi√©n te la puedes encontrar como `--verbose`. `tar -cvf compressed.tar Documents/toCompress/`
- Para manejar la compresi√≥n de archivos ".tar.gz" o ".tgz" se usa la opci√≥n `-z` adem√°s de tener que especificar en el nombre de archivo la extensi√≥n que quieres usar. `tar -czvf compressed.tar.gz Documents/toCompress/`
- Si se quiere descomprimir un archivo de extensi√≥n ".tar.gz" o ".tgz" hay que especificar la opci√≥n `-z` tambi√©n. `tar -xzvf compressed.tar.gz`
- Si quieres comprimir una carpeta con archivos dentro, tienes que especificar la opci√≥n `-r` de "recursive". `zip -r copressed.zip Documents/toCompress/`
- Para descomprimir es incluso m√°s f√°cil, solo escribe el comando `unzip` seguido de lo que quieres descomprimir. `unzip compressed.zip`

| Opci√≥n | Funci√≥n | 
| --- | --- | 
| c | Comprimir | 
| x | Descomprimir | 
| z | Especifica que lo que se va a comprimir o descomprimir tiene extensi√≥n ".tar.gz" o ".tgz" | 
| v | Muestra lo que est√° comprimiendo o descomprimiendo |

> Recuerda siempre colocar la opci√≥n -f.

| Comando | Funci√≥n | 
| --- | --- | 
| zip | Comprimir | 
| unzip | Decomprimir |

## Manejo de Procesos

Puedes manejar los procesos como visualizar, eliminar o filtrar desde la terminal.

- El comando `ps` muestra los procesos que est√°n activos en una tabla muy sencilla de entender, donde el la primera columna tenemos el process ID y en la √∫ltima el nombre.
- Si quieres ver una lista m√°s detallada de los procesos con su consumo en CPU y en RAM, adem√°s del usuario que lo activ√≥, usamos el comando `top`.
   - Aqu√≠ podemos filtrar por user. Si presionas la tecla "u" podr√°s escribir el nombre de usuario por el cual quieres buscar y si presionas la tecla "h" te mostrar√° un cuadro de ayuda para m√°s opciones. Para salir presiona "q".
- Para matar un proceso usamos el comando `kill` seguido del PID del proceso que queremos matar.

| Comando | Funci√≥n | 
| --- | --- | 
| ps | Muestra una tabla con los procesos que se est√°n ejecutando | 
| top | Muestra una interfaz con los procesos que se est√°n ejecutando m√°s los recursos que consumen informaci√≥n adicional | 
| kill | Mata el proceso que le indiques |

## Procesos en foreground y background

Podemos correr de manera as√≠ncrona comandos, y si estos no se completan quedar√°n activos dentro de los procesos de la terminal. Cuando un proceso est√° en ejecuci√≥n sin que sea mostrado en la terminal se dice que se est√° ejecutando en el background. Si se muestra la ejecuci√≥n del comando dentro de la terminal se dice que est√° en el foreground. 

Imagina que queremos una nota desde la terminal y para eso usamos: `cat > mi_nota.txt`. Nuestra terminal se ver√° de la siguiente manera, con el prompt esperando a que ingresemos texto. 

Podemos escribir algo y despu√©s terminar el input del texto con `CTRL+D`, pero en esta ocasi√≥n no haremos eso. Lo que queremos hacer ser√° suspender el proceso, esto lo podemos hacer con `CTRL+Z`. El resultado que nos mostrar√° la terminal deber√° ser uno donde nos indique la suspensi√≥n del comando `cat`. 

```bash
[1]  + 26403 suspended  cat > mi_nota.txt
```

Ahora hemos movido nuestro comando exitosamente al `background` de la terminal. Para consultar todos los procesos que tenemos en `background` podemos hacerlo con el comando `jobs`.
```bash
[1]  + suspended  cat > mi_nota.txt
```

A la izquierda aparece el n√∫mero del trabajo (‚ö† cuidado que no es lo mismo que el process ID). Si queremos traer la ejecuci√≥n de nuevo a la terminal, es decir, al foreground; debemos usar el comando `fg` y especificar qu√© n√∫mero de trabajo queremos continuar.
```bash
fg 1
```
Si usas **ZSH**
```bash
fg %1
[1]  + 26403 continued  cat > mi_nota.txt
```
Una vez enviado al foreground veremos como se activa la ejecuci√≥n del comando en la terminal y podremos seguir escribiendo nuestra nota. Recuerda que una vez terminemos de escribir presionamos `CTRL+D`para terminar el input y guardar.

Otra forma de enviar al background `cat > mi_nota.txt &`, otra opci√≥n `bg 1` este sirve de manera similar que `fg` solo que en vez de traerlo al `foreground` este lleva un trabajo al `background`.

## Editores de texto en la terminal

Existen varios editores de texto que se utilizan en la terminal, y aqu√≠ un breve resumen de los m√°s populares:

- Vim: Es un editor muy potente y popular entre desarrolladores. Ofrece modos de inserci√≥n y normal, resaltado de sintaxis y es altamente configurable. Requiere tiempo para aprender, pero es muy eficiente una vez dominado.

- Nano: Es un editor m√°s simple y f√°cil de usar, ideal para principiantes. Su interfaz es amigable y no requiere complejas combinaciones de teclas, haci√©ndolo accesible para todos.

- Emacs: Es un editor vers√°til, conocido por su extensibilidad. Permite personalizaciones profundas y tiene una curva de aprendizaje m√°s pronunciada, pero es muy poderoso para quienes lo dominan.

Cada uno tiene sus ventajas y desventajas, y la elecci√≥n depende de las preferencias y necesidades del usuario.

## Personalizar la terminal de comandos

En la personalizaci√≥n de la terminal se pueden realizar los siguientes tipos:

- Cambiar el emulador de terminal: Como TILIX para Linux, que permite dividir la ventana en varias terminales.
- Instalar una nueva shell: Por ejemplo, Zsh, que mejora la experiencia con funciones adicionales.
- Configurar un tema: Usar temas como Powerlevel10k, que ofrecen visualizaci√≥n avanzada y colores.
- Modificar la fuente: Elegir fuentes que permitan mostrar √≠conos y mejorar la est√©tica.
- Configurar archivos de configuraci√≥n: Editar el archivo .zshrc para personalizar la funcionalidad de la shell.

Estas personalizaciones hacen que la terminal sea m√°s c√≥moda y visualmente atractiva.

### Enlaces

- <https://platzi.com/blog/terminal-en-big-sur-mas-bonita-que-nunca/>
- <https://gnunn1.github.io/tilix-web/>
- <https://ohmyz.sh/>
- <https://github.com/romkatv/powerlevel10k>
- <https://www.edevars.com/blog/personalizar-terminal>


# Next

Recomendaciones de lectura:
- <https://nostarch.com/linuxbasicsforhackers>
- <https://nostarch.com/tlcl2>
- <https://www.oreilly.com/library/view/grep-pocket-reference/9780596157005/>
- <https://www.oreilly.com/library/view/learning-the-vi/9780596529833/>
- <https://www.oreilly.com/library/view/linux-pocket-guide/9781491927557/>
- <https://www.oreilly.com/library/view/regular-expression-pocket/9780596514273/>

# Instalando WSL

**WSL** es la base con la que haremos que alguna distribuci√≥n de Linux pueda correr dentro de nuestra computadora con Windows 10 u 11. 

Una vez que se tenga instalada esta herramienta podr√°s instalar una gran variedad de distribuciones de Linux como Ubuntu o Debian. Para nuestro caso instalaremos Ubuntu que se instala por defecto al instalar WSL, pero puedes escoger alguna otra por la que tengas preferencia y ya sepas utilizar.

1. Abre Windows PowerShell desde inicio en Widows. Para ello b√∫scala y da clic derecho sobre Ejecutar como Administrador.
2. Dentro de Windows PowerShell escribe la siguiente instrucci√≥n y presiona la tecla Enter: `wsl --install`
3. Espera a que la barra de instalaci√≥n llegue al 100% y presiona `Enter` nuevamente. Eso iniciar√° el proceso de instalaci√≥n del sistema operativo Ubuntu.
4. Espera a que la barra de instalaci√≥n de Ubuntu llegue al 100%.
5. A finalizar la instaci√≥n reinicia tu computadora para aplicar los cambios.
6. Una vez que se haya reiniciado la computadora te llevar√° a configurar Ubuntu.
7. Ingresa el username y password de tu preferencia. Recuerda muy bien tu password, ya que deber√°s usarla al utilizar el sistema operativo Ubuntu desde WSL.
8. Listo, ya tienes WSL y Ubuntu instalados en tu computadora con Windows. Para acceder nuevamente a Ubuntu en WSl abre la aplicaci√≥n Terminal desde inicio de Windows.
9. Dentro de Terminal da clic en la flecha hacia abajo y elige la opci√≥n de Ubuntu.

Para m√°s informaci√≥n en la [documentaci√≥n oficial de Microsoft](https://learn.microsoft.com/es-mx/windows/wsl/install) sobre **WSL**.

# Principios de usabilidad y Heur√≠s¬≠stica:

1. **Visibilidad del estado del sistema:** el usuario deber√° saber que  est√° pasando en cada interacci√≥n con el producto (cargando, guardando,  errores). Debe recibir un feedback del estado del producto.
2.  **Relaci√≥n producto y mundo real:** El usuario no deber√° tener dudas al  momento de interactuar con el sistema, se le debe brindar toda la  informaci√≥n para que pueda operar el sistema.
3.  **Control y libertad del usuario**: El usuario debe poder cancelar o salir de un proceso, sin finalizarlo y sin compromisos.
4. **Consistencia:** En el dise√±o de los bloques visuales del flujo del  sistema, tratar de llevar un patr√≥n en todos los elementos del sistema.
5. **Prevenci√≥n de errores:** Proveer instrucciones claras de lo que se espera que el usuario realice dentro de nuestro producto.
6. **Reconocer antes de recordar:** Entregar informaci√≥n valiosa al usuario y ademas proveer una forma en que el usuario pueda revisarla cuando la  necesite sin acudir a su memoria.
7. **Flexibilidad y eficiencia de uso:** Entregar una interfaz capaz de  satisfacer a usuarios avanzados y no avanzados. Permitir el uso del  producto sin necesidad de conocimientos especializados.
8. **Dise√±o est√°tico y minimalista:** no saturar de contenido al usuario, mostrar √∫nicamente el contenido relevante para cada vista o cada acci√≥n que el usuario ha decidido acceder. No poner elementos que distraigan al usuario del objetivo de la vista.
9. **Ayudar al usuario a reconocer y corregir errores:** Dar informaci√≥n al  usuario de lo que esta generando errores o inconsistencias en el  sistema.
10. **Ayuda y documentaci√≥n:** Detectar las dudas mas comunes de los  usuarios a la hora de usar nuestro producto y proveer informaci√≥n que  pueda resolverlas de manera inmediata.

# Recursos

 - [Command Line Cheat Sheet](/files/command-line-cheat-sheet.pdf)

# Atenci√≥n

Este tutorial es basado en el Curso de Introducci√≥n a la Terminal y L√≠nea de Comandos de Platzi.