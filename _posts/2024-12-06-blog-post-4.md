---
title: 'Introducción a la Terminal y Línea de Comandos'
date: 2024-12-06
permalink: /posts/2024/12/blog-notes-4/
tags:
  - cool posts
  - category1
  - category2
  - platzi
---

Tutorial introductorio a la Terminal y Línea de Comandos.

Si alguna vez viste una película de hackers, seguro has visto la ventana negra que abren en sus computadores, dónde escriben muchas letras sin sentido. Esto se conoce como terminal, pero, te lo explicaremos más a detalle. 

# Intro

La terminal es un programa que ejecuta líneas de comandos, que a su vez estas líneas de comando ejecutan acciones y aquí tienes que aprender dos conceptos: terminal y shell.

## Terminal

Estamos muy acostumbrados a que en nuestra computadora inicie un sistema operativo que tenga un sistema de ventanas en el que podemos abrir carpetas y programas y podamos mover archivos a través de una interfaz gráfica. La terminal es otra ventana más, es un programa, una interfaz que recibe un comando para luego pasárselo a la shell y que esta última la ejecute. Con este programa podemos hacer todo lo que el sistema de carpetas e interfaz gráfica del sistema operativo puede hacer, pero utilizando comandos.

## Shell

Ahora la terminal no ejecuta líneas de código, solo la recibe, es la shell quien hace todo el proceso de tomar el comando, ir con el procesador y la memoria RAM y decirles "tomen, ejecuten esto". Si lo pensamos de otra forma, la shell nos proporciona una forma de comunicarnos con el procesador y la RAM sin tener que pasar por la interfaz gráfica

## Comando

Un programa que se puede ejecutar desde la terminal. Este puede recibir parámetros y opciones. 

### ¿Qué es un comando?

1. Un programa ejecutable.
2. Un comando de utilidad de la shell.
3. Una función de shell.
4. Un alias.

Ejemplos de comandos básicos de la terminal
Ahora conocerás varios tipos de comandos que puedes aplicar en el proyecto que estás realizando.

- `type` <comando>: Nos permite conocer qué tipo de comando es 🤔.
- `alias l="<secuencia de comandos>"`: Nos permite crear comandos. Son temporales, se borran al cerrar la terminal 👶🏼.
- `help` <comando>: Nos permite consultar un poco de documentación de un comando 📄.
- `man` <comando>: De manual, nos permite conocer mucha más información de un comando.
- `info` <comando>: Similar al anterior, pero un poco resumido y con otro formato.
- `whatis` <comando>: Describe un comando en una sola línea ☺️. No funciona con todos.

[41 comandos de la terminal que debes conocer](https://platzi.com/blog/41-comandos-terminal/)

# Primeros pasos

## Sistema de Archivos

![image_1](/images/terminal/file_system.png)

> Adicional: <https://www.geeksforgeeks.org/linux-file-hierarchy-structure/>

La carpeta con el símbolo `"/"` es la raíz, ahí es donde comienza todo el sistema de ficheros (el equivalente en Windows podría ser el fichero `"C:\"`). Dentro de esta carpeta hay varios ficheros, el que nos importa en este momento es el "Home".

La carpeta "Home" contiene una carpeta por cada usuario del sistema y ya dentro de cada una de estas carpetas, estarán las carpetas que conocemos de toda la vida como imágenes, documentos, música, etc.

### Atajos

- Virgulilla (`~`): indica la carpeta del usuario en el home.

- Punto y doble punto (`.`) (`..`): No siempre quieres ir hacia adelante, a veces necesitas devolverte, para eso utilizas el atajo del doble punto (`..`) que te envía a la carpeta que está atrás. Por otro lado, el punto (`.`) índica la carpeta actual, así puedes hacer direcciones más precisas.

### Comando `ls`

Este comando lista los archivos y carpetas dentro del directorio que selecciones.

Para saber información adicional como la fecha de creación, el peso, los permisos, etc., utilizamos la opción `-l` que significa `Long`.

Lo anterior nos muestra una tabla que tiene mucha información, pero céntrate en la columna que son el peso, pero el peso en bytes, lo cual lo hace un poco complicado de leer. Podemos añadir la opción `-h` que significa `Human Readable`.

El comando `ls -lS` ordena por peso los archivos y carpetas.


> Nota: para añadir más de una opción no hacemos esto `ls -l -h` sino esto `ls -lh`.

### Resumen de Comandos

Comando | Función | 
| --- | --- | 
| pwd | Print Working Directory: Muestra en la carpeta en la que estas | 
| cd | Change Directory: Te mueve a la carpeta que desees | 
| ls | List: Lista los archivos y carpetas dentro del directorio que selecciones | 
| file | Muestra la información del archivo que selecciones |

## Manipulando archivos y directorios


| Comando | Función | 
| --- | --- | 
| mkdir | Crea carpetas | 
| touch | Crea archivos | 
| cp | Copia archivos | 
| mv | Mueve archivos | 
| rm | Elimina archivos o carpetas |

- Para copiar un archivo usando la terminal solo debes escribir el comando `cp` (`cp` es de Copy) seguido del nombre del archivo que deseas copiar y, por último, el nombre con el que quieres que se guarde la copia.

- La sintaxis para el comando `mv` (`mv` es de Move) es igual que la del comando `cp`. Primero el nombre del archivo que quieres mover y luego a donde se va a mover.

- Para eliminara, solo debes escribir el nombre o la ruta del elemento que quieres eliminar y delante del comando `rm` (`rm` es de Remove). El comando `rm` tiene varias opciones. Las más usadas son: 
  - `-i` (de interactive) te pregunta si estás seguro de eliminar el archivo 
  - `-r` (de recursive) elimina todo lo que esté dentro de una carpeta 
  - `-f` (de force) fuerza a borrar todo. (La opción `-f` se usa cuando no puedes borrar algún archivo, bien sea porque algo lo está usando o porque se está ejecutando.)

## Explorando el contenido de nuestros archivos

| Comando | Función | 
| --- | --- | 
| head | Muestra las primeras 10 líneas | 
| tail | Muestra las últimas 10 líneas | 
| less | Muestra todo el contenido dentro de la consola | 
| xdg-open | Abre un programa para inspeccionar ese archivo | 
| nautilus | Abre en la interfaz de ventanas la carpeta que selecciones |

En español, cabeza y cola tienen una funcionalidad muy sencilla, `head` imprime las primeras 10 líneas de un archivo y `tail` imprime las 10 últimas líneas.Si no quieres ver las primeras líneas, sino que quieres ver las primeras 20, por ejemplo, entonces usas la opción `-n` seguida del número de líneas que quieres ver.

- Para observar todo el contenido de un archivo, escribes el nombre del archivo que quieres abrir y delante del comando `less`. Ahora tendrás una especie de interfaz gráfica donde podrás inspeccionar el documento. Puedes usar las flechas y el scroll para moverte arriba y abajo. Además, puedes buscar palabras dentro del documento. Si presionas la tecla slash `"/"`, en la parte de abajo se habilitará un cuadro donde podrás buscar palabras, solo escribe y presiona `enter`. Para salir de la interfaz presiona `"q"`.

- Abrir en un programa el archivo podemos emplear el comando `xdg-open` es sencillo porque hace algo muy simple, abre el archivo que desees en el programa predeterminado para su extensión. 

- Pues como todo programa lo podemos ejecutar desde la consola usando el comando `nautilus` se usa igual que `xdg-open`, solo que debes seleccionar una carpeta.

## Alias

Ahora, podemos crear nuestro propio comando con un alias llamado `l`:

```shell
alias l="ls -lh"
```

Pero si cerramos y volvemos a abrir la terminal, este alias se pierde. Existen formas de almacenar todos los alias creados.

## Wildcards

Las wildcards o comodines son una serie de caracteres especiales que nos permiten encontrar patrones o realizar búsquedas más avanzadas. Es aplicable para archivos y directorios.

Las wildcards te sirven para realizar seccionamiento de archivos o directorios, además de `ls` los wildcards tambien pueden usarse con cualquier comando que realice la manipulación de archivos como `mv`, `cp` y `rm`.

### Tipos de wildcards

| Wildcard | Función | 
| --- | --- | 
| * | Busca todo | 
| ? | Busca por cantidad de caracteres | 
| [] | Busca por caracteres específicos |


- **Buscar todo (*):** el asterisco te ayuda a buscar toda la información dentro de una carpeta, pero puedes limitar su uso. Si por ejemplo quieres buscar los archivos que tengan una extensión ".png", escribes: `ls -l *.png`. 
  - También lo puedes poner al final, si quisieras buscar, todos los archivos que comiencen por unos caracteres específicos, entonces escribes esos caracteres y luego el asterisco. Por ejemplo, si quisieras buscar todos los archivos que comiencen por `"fotosDe"`, habría que escribir: `ls -l fotoDe*`

- **Buscar por cantidad de caracteres (?):** si dentro de tus archivos tuvieras una especie de código para guardar tus fotos, algo así como "foto1.png", "foto2.png", "foto3.png", etc. En este caso, sabemos que primero tenemos el string "foto", luego un solo número y por último la extensión ".png". Si quisieras buscar esas fotos escribirías: `ls -l foto?.png`.
  - Pero si sabes que no tiene un solo caracter, sino que tiene varios, entonces escribes tantos signos de interrogación como caracteres existan. Por ejemplo, si quieres buscar las fotos que tengan esta estructura "foto11.jpg", escribes: `ls -l foto??.jpg`

- También puedes combinar wildcards. Por ejemplo, si sabes que tus fotos siguen esta especie de código, pero no sabes que extensión tienen, escribes: `ls -l foto?.*`

- **Buscar por caracteres específicos ([]):** si quieres buscar por varios caracteres específicos se usan corchetes. Para utilizarlos tienes que colocar dentro de los corchetes los caracteres que quieres buscar.Por ejemplo, si quisieras buscar los archivos que comiencen por las letras "c" o "i", entonces escribes: `ls -l [ci]*`
  - Cuando buscamos con esta wildcard ten en cuenta que es case sensitive, por lo que la letra "i" no es lo mismo que la letra "I". `ls -l [cCiI]*`
  - Si quieres buscar por rango de números también tienes que usar esta wildcard. Para hacerlo, escribe el rango de números que quieres buscar separados por un guion. `ls -l foto[2-6]*`
  - Con el siguiente comando buscamos directorios que comiennce con mayúsculas `ls -d [[:upper:]]*` 
  - Para buscar por números se puede usar: `ls [[:alnum:]]*` o `ls [[:digit:]]*`
    - Clases dentro de los Wildcards:
      - `[:alnum:]` Coincide con cualquier carácter alfanumérico
      - `[:alpha:]` Coincide con cualquier carácter alfabético
      - `[:digit:]` Coincide con cualquier número
      - `[:lower:]` Coincide con cualquier letra minúscula
      - `[:upper:]` Coincide con cualquier letra mayúscula

### Truco

Si quieren que el alias permanezca en la terminal y no se pierda cuando la cierren pueden guardar los alias al final del archivo que se encuentra en el `home` de cada pc llamado en el caso de bash es `~/.bashrc` y después de guardarlo le das el comando `source ~/.bashrc` para que se apliquen los cambios.

# Empezando a correr

## Redirecciones

¿Qué son las entradas y salidas de la terminal?

En la consola nosotros generamos una entrada cuando escribimos y una salida casi siempre que ejecutamos un comando. A las entradas típicamente se les suele llamar `Standard Input` y a las salidas `Standard Output`, además se les suele abreviar como `stdin` y `stdout` respectivamente.

Los **file descriptors** son números que identifican un recurso. Funciona asociando un número con una acción, archivo o programa, en el caso de la shell tenemos 3 file descriptors:

0. stdin
1. stdout
2. stderr (Standard Error)

| Operador | Función | 
| --- | --- | 
| > | Redirecciona la salida. Por defecto redirecciona el Standar Output |
| < | Redirecciona la entrada a algún comando. Es algo raro este uso |
| >> | Concatena la salida con lo que ya tenga el archivo a donde se está redirigiendo la salida | 
| 2> | Redirecciona el file descriptor 2 (En este caso Standar Error) | 
| 2>&1 | Redirecciona el file descriptor 2 y 1 |

Si queremos guardar la información de una salida porque nos puede interesar almacenar lo que esa salida contiene. Veamos el siguiente ejemplo, si utilizas el comando: `ls -l`. Si quieres que el `Standard Output` no vaya a la consola sino hacia un archivo, entonces puedes usar el operador `>` seguido del nombre del archivo en el que quieres guardar la salida. `ls -l > output.txt`

Si se tiene el archivo `output.txt` y ahora también quieres guardar la información de la carpeta de documentos, entonces no puedes volver a ejecutar: `ls -l > output.txt`, esto lo que hará es reescribir el contenido del documento, lo que necesitas es **concatenar** el contenido del documento con el de la salida, para eso ejecutas: `ls -l >> output.txt`.

El operador de redirección por defecto solo redirecciona el file descriptor 1 (es decir, el `Standard Output`). Vamos a generar un error ejecutando un comando que saldrá mal para redirigirlo a un archivo llamado "error.txt". `ls -lñ 2> error.txt`

También podemos especificar que no importa lo que pase si me da un Standar Ouput o un Standar Error, igual tiene que guardar la salida en un archivo. Esto lo hacemos así: `ls -l > output.txt 2>&1`. La orden `2>&1` significa que debe redirigir el file descriptor 2 y el file descriptor 1.

## Pipe operator

**Pipe operator** es un operador que permite tomar la salida de un comando y pasarla como entrada de otro comando. 

| Comando | Función | 
| --- | --- | 
| sort | Organiza allfabéticamente una salida | 
| cat | Concatena dos entradas | 
| tee | Crea un archivo en base a una entrada |

- Si queremos crear una lista de los archivos de varias carpetas, podemos usar `cat` para concatenar la salida de varios de ellos. 
  - `ls ./Downloads > descargas.txt` `ls ./Documents > documentos.txt` `cat descargas.txt documentos.txt`

- Si queremos guardar la lista creada anteriormente, podemos pasar esa salida por medio de un pipe operator al comando `tee`, el cual creará un archivo con esa salida.
  - `cat descargas.txt documentos.txt | tee archivos.txt`

- Puede ser algo complicado encontrar un archivo dentro de la lista, por lo que lo podemos organizar alfabéticamente una salida con el comando `sort`.
  - `ls | sort | tee archivosHome.txt`

- Ver mi directorio y salvarlo en un arhivo:
  - `ls -lh | tee output.txt | less`
  - Aplicando filtro sort `ls -lh | sort | tee output.txt | less`

### Comandos nerd

- `cowsay`
  1. Install: `sudo apt install cowsay`
  2. cowsay "mensaje"

- `lolcat`
  1. Install: `sudo apt install lolcat`
  2. echo "mensaje" | lolcat

- Uso curioso `cowsay "mensaje" | tee vaca.txt | lolcat`

## Encadenando comandos: operadores de control

 Operador | Función | 
 | --- | --- | 
 | ; | Ejecuta de forma síncrona los comandos específicados | 
 | & | Ejecuta de forma asíncrona los comandos específicados | 
 | && | Ejecuta el comando si el anterior se ejecutó correctamente | 
 | \|\| | Ejecuta el comando si el anterior o la combinación de los anteriores resultaron en verdadero |


| Comando | Función | 
| --- | --- | 
| echo | Imprime el mensaje que le indiques | 
| cal | De calendar imprime un calendario con la fecha actual | 
| date | Imprime la fecha actual |

Los operadores de control son símbolos reservados por la terminal que nos permiten encadenar comandos. Si usas constantemente la tecla enter para ejecutar varios comandos, puedes evitarlo si usas el `operador ;` que separa los comandos que estamos ejecutando.

- **Comandos en la misma línea (;):** Solo necesitas escribir los comandos que quieres ejecutar separados por `;` y luego presionar `enter`.`mkdir ProyectosSecretos; ls; date`

- **Comandos asíncronos (&):** Cuando queremos ser más eficientes podemos ejecutar varios comandos al mismo tiempo, de modo que no tenemos que esperar a que uno se ejecute para luego ejecutar el que sigue. Para llevar a cabo varios comandos, al mismo tiempo, usamos el `operador &` entre cada comando que queremos ejecutar. `date & echo "Hola" & cal`

- **Comandos con condicionales**:
  - **Condición and (&&):** estamos indicando que para que estos se ejecuten, el comando anterior tuvo que ejecutarse correctamente. `cd lp && mkdir Comida`
  - **Condicional or (||):** Al condicional or no le importa si el comando anterior se ejecutó o no, simplemente va probando todos los comandos a ver cuál se ejecuta. `cd ProyectosSecretos/ || cambia-carpeta ProyectosSecretos/`
  - **Combinando operadores de control:** `cd ProyectosSecretos/ || cambia-carpeta ProyectosSecretos/ && mkdir ProyectoIncreible`

## Cómo se manejan los permisos

> Se pueden representar los permisos de forma octal. <https://platzi.com/tutoriales/1667-linux/8811-cosas-que-nos-sabias-sobre-el-sistema-de-permisos-de-linux-realmente-es-octal/>

Los permisos son las capacidades que tiene cada usuario dentro del sistema operativo, no todos los usuarios pueden hacer todas las acciones sobre ciertos archivos y carpetas.

### Tipo de archivo

| Atributo | Tipo de archivo | 
| --- | --- | 
| - | Es un archivo normal, como un documento de texto, una foto, un video, etc. | 
| d | Por directory es un directorio | 
| l | Es un enlace simbólico. Es algo que veremos en próximas clases | 
| b | Bloque especial, son archivos que manejan información para el sistema, como la información de un disco duro |

### Permisos de usuario

- Owner: El dueño del archivo, si no se ha cambiado, es quien lo creo y tiene mayor jerarquía sobre los otros 3. Le corresponden los primeros 3 caracteres de los permisos.
- Group: Se puede crear grupos de usuarios para darle a todos o varios los mismos permisos. A estos usuarios le corresponden el cuarto, quinto y sexto caracter de los permisos de usuarios y tienen mayor jerarquía que el último.
- World: También llamado "otros", es cualquier otro usuario que no pertenezca a un grupo de usuario y tampoco sea el dueño, este tiene la menor jerarquía.

### Tipos de permisos

| Símbolo | Significado | Permiso | 
| --- | --- | --- | 
| r | readable | Significa que puede leer su contenido | 
| w | writable | El usuario puede editar el contenido del archivo, también el nombre y los permisos | 
| x | executable | El usuario puede ejecutarlo en caso de que sea un programa |

Los permisos se escriben en ese orden `rwx`. Para indicar que el permiso no está disponible, se escribe un guion.

#### Ejemplo

Observa el siguiente grupo de permisos: `drwxr-xr-x`.

Recuerda que el primer caracter es el tipo y los siguientes se cuentan de 3 en 3 representando cada usuario.

| d | rwx | r-x | r-x | 
| --- | --- | --- | --- | 
| Esto es un directorio | owner | group | world | 
|| El dueño puede leer, escribir y ejecutar | El grupo puede leer y ejecutar | Los demás pueden leer y ejecutar |

Vamos con otro

`-rw-r--r--`

| - | rw- | r-- | r-- | 
| --- | --- | --- | --- | 
| Esto es un archivo normal, como una imágen o un video | owner | group | world | 
| | El dueño puede leer y escribir | El grupo sólo puede leer | El resto sólo puede leer |


### Práctica

Este concepto puede ser algo complicado así que lo mejor es prácticar, te dejaré unos ejercicios para que sea más fácil interpretarlo.

Convierte los siguientes permisos a símbolos y en su representación numérica:

1. De un directorio, el dueño tiene permiso de lectura y escritura, el grupo tiene permisos de escritura y ejecución y world no tiene permisos.
2. De un enlace simbólico, el dueño tiene todos los permisos, el grupo y world sólo de lectura.
3. De un archivo común, todos tienen todos los permisos, pero el world no tiene permiso de ejecución.

> Crear enlace símbolico: `ln -s [ruta/del/archivo/original] [ruta/del/enlace/simbolico]`

## Modificando permisos en la terminal

| owner | group | others | 
| --- | --- | --- | 
| u (de user) | g | o |


| Operador | Función | 
| --- | --- | 
| + | Añade un permiso | 
| - | Quita un permiso | 
| = | Asigna un permiso |

`chmod [simboloDelUsuario][operador][permiso] [archivoParaCambiarSusPermisos]`

Supongamos que queremos añadirle permiso de escritura al grupo, entonces tenemos que escribir lo siguiente: `chmod g+w file_test.txt`

Puedes cambiar varios permisos de varios usuarios al mismo tiempo, por ejemplo, si quisieras agregar el permiso de escritura y ejecución al grupo y a otros, sería así: `chmod go+wx [archivo]`

Y si quieres permisos diferentes para cada usuario, solo sepáralos por comas: `chmod u+r,g=w [archivo]`

> También puedes cambiar los permisos usando su forma octal.

### Gestionar usuarios `(whoami | su)`

El comnando `whoami`, literalmente "¿Quien soy yo?", te muestra cual es el usuario que se está ejecutando, esto es porque a veces podemos olvidar con cual usuario estamos trabajando.

Para cambiar de usuario se usa el comando su Switch User, seguido del usuario al que quieres cambiar, en este caso vamos a cambiar al superusuario root. `su root`

> **Cuidado:** el superusuario `root` (sí, ese es el nombre técnico) tiene poder para hacer y deshacer con el sistema operativo, puedes eliminar cosas que no deberías eliminar y puede hacer mucho desastre. Usa los privilegios del `root` con cuidado.

### Cambiar el propietario (chown)

Puede que no te quieras hacer responsable de tus archivos, así que se los quieres dejar a alguien más. Para eso usa el comando `chown` Change Owner. La sintaxis es muy simple: `chown [usuarioAlQuePertenecerá] [archivo]`

| Comando | Función | 
| --- | --- | 
| whoami | Muesta el usuario con el que se está trabajando | 
| su | Switch User Cambia al usuario al que le especifiques | 
| chmod | Cambia los permisos de un archivo | 
| chown | Change Owner Cambia el propietario de un archivo |

#### Práctica

Recuerda que si haces mucho desastre puedes borrar casi lo que sea con el usuario root y ten mucho cuidado con lo que borras.

1. Crea un archivo llamado "ArchivoPoderoso.txt", luego dale los permisos r-xrwxr-xr-x usando la forma simbólica del comando chmod.
2. Crea un archivo con el usuario root llamado "pelota.txt", luego dale los permisos rwxr-x--x usando la forma numérica del comando chmod y luego cambia el propietario a tu usuario principal con chown.
3. Crea un archivo con un nombre bonito y asígnale los permisos --------- usando su forma simbólica.

## Cómo configurar variables de entorno

Las variables de entorno son útiles cuando necesitamos que cierta información prevalezca para poder trabajar más rápido o necesitamos guardar información para no tener que recordarla constantemente.

| Variable | Contenido | 
| --- | --- | 
| HOME | Indica el home del usuario | 
| PATH | Indica las direcciones de donde están los binarios que usa el sistema | 
| BASH_VERSION | Indica la versión del bash que estás utilizando | 
| SHELL | Dirección de la shell que estás utilizando |

`echo $HOME`

> Por convención las variables de entorno se crean en mayúsculas.

## ¿Cómo crear tus propias variables de entorno?

En el home de tu usuario debe haber un archivo oculto llamado `".bashrc"`, lo puedes ver ejecutando el comando `ls -la` la opción `-a` es de all. `ls -la`

> Pero se puede hacer mejor porque también puedo crear un `alias` que no se borre cuando cierre la terminal.

> Nunca crees alias de comandos que ya existe, carece de lógica.

### WSL

Desde WSL, podemos abrir `.bashrc` utilizando el comando `code .bashrc`, si tienes instalado `VS Code` esto te mostrará el documento en el editor. Si estás en WSL y no te funciona, ve a la `cmd`, ejecuta el comando `wsl` y vuélvelo a intentar desde ahí.

Vamos a crear una variable de entorno que me de la ruta de mi carpeta en Windows sin que tenga que escribir toda la ruta.

`WINDOWS="/mnt/c/users/user_test/`

Ahora guardo el archivo, reinicio la terminal y ejecuto:

`cd $WINDOWS`

## Comandos de búsqueda

A veces necesitas localizar varios archivos del mismo tipo que ocupan espacio innecesario en tu disco duro.

Por ejemplo, algunos programas que funcionan desde la consola, como npm, guardan sus errores en archivos de extensión ".log" y si no estás pendiente de eliminarlos se van acumulando en tu disco duro.

- Para encontrar archivos de forma efectiva, usa el comando `find`, el cual buscará en la ruta que le indiques el tipo de archivos que necesitas. Su sintaxis es: `find [rutaDesdeDondeEmpezarBuscar] [opciones]`
  - Segmentar por el nombre (`-name`): `find ./ -name *.png`
  - Segmentar por el tipo (`-type`): la opción `-type`, el cual acepta `f` para archivos, `d` para directorios y `l` para enlaces simbólicos: `find ./ -type f -name "f*"`
    - Veamos un ejemplo buscando archivos y directorios: `find ./ -type f,d -name "D*"`
  - Segmentar por tamaño (`-size`): hay que colocar la unidad de peso **c** para byte, **k** para Kilobyte, **M** para Megabyte y **G** para Gygabyte. `find ./ -size +4k`
  - Buscar vacíos (`-empty`): `find ./ -type d -empty`
  - Limitar la búsqueda (`-maxdepth` `-mindepth`): `find ./ -type d -maxdepth 2` 
  - Una última cosa, es recomendable pasar el output al comando `less`, así: `find ./ | less`

| Opción | Función | 
| --- | --- | 
| -size | Busca por el peso | 
| -mindepth | Asigna una profundidad mínima | 
| -maxdepth | Asigna una profundidad máxima | 
| -type | Busca por el tipo de archivo | 
| -name | Busca por el nombre del archivo |

### Práctica

El abito hace al monje y la terminal al buen programador.

Crea el comando `find` para cada uno de estos casos: 
1. Busca tus archivos mayores a 100Mb, con una profundidad máxima de 4, que comiencen por la letra d. 
2. Busca los archivos que tengan extensión ".pdf" con una profundidad mínima de 2. 
3. Busca todas las carpetas que comiencen por la letra "A" con una profundidad máxima de 5, que estén vacías. 
4. Busca todo lo que tenga una letra "j" que pese más de 1b. Luego guarda la salida en un archivo llamado "LosArchivosJ.txt" y cuando termine de hacer todo eso imprime un mensaje que diga "Comando terminado con éxito".

---
Algunos los tuve que modificar debido a la ausencia de resultado para comprobar

1. `find ~/Documents/ -maxdepth 4 -type f -name 'a*' -size +10M | tee test1.txt && echo "End test 1"`
```
/home/riacosta/Documents/Science Books/Robotica/automatizacion-robotica.pdf
/home/riacosta/Documents/Science Books/0_Inbox/arm-designing-embedded-system-application-cortex-m.pdf
End test 1
```
2. `find . -mindepth 2 -type f -name '*.pdf' | tee test2.txt && echo "End Test 2"`
`head test2.txt`
```
./Desktop/Informatic_2024.pdf
./Desktop/BertJanssen-RelatividadGeneral.pdf
./Desktop/Algebra_Lineal_Aplicada.pdf
./Desktop/ON THE ELECTRODYNAMICS OF MOVING_Einstein_1905.pdf
./Desktop/Hola/Turno_1.pdf
./Desktop/precaria_2756339.pdf
./Desktop/Nota_Integral.pdf
./Desktop/PhD_thesis_FINAL_241205_145223.pdf
./Desktop/Sum_of_Odd_Cubes.pdf
./Desktop/Sums of Reciprocals of Binomial Coefficients.pdf
```
3. `find . -maxdepth 5 -type d -empty -name 'A*'`

4. `find . -type f -name 'j*.txt' -size +1c > LosArchivosJ.txt && echo "Comando terminado con exito"`
`head LosArchivosJ.txt`
```
./env_phd/lib/python3.10/site-packages/scipy/io/matlab/tests/data/japanese_utf8.txt
./Documents/Programming/Platzi/env_eda/lib/python3.10/site-packages/scipy/io/matlab/tests/data/japanese_utf8.txt
./Documents/Programming/Platzi/env_platzi/lib/python3.10/site-packages/scipy/io/matlab/tests/data/japanese_utf8.txt
./STM32Cube/Repository/STM32Cube_FW_F4_V1.28.1/Middlewares/Third_Party/LibJPEG/jconfig.txt
./STM32Cube/Repository/STM32Cube_FW_F4_V1.28.1/Middlewares/Third_Party/LibJPEG/jdosaobj.txt
```

<https://linuxhint.com/differences_between_bash_zsh/>

## Usando el comando grep

| Opción | Función | 
| --- | --- | 
| -m | Limita las líneas de la búsqueda | 
| -c | Cuenta las ocurrencias | 
| -v | Excluye las ocurrencias | 
| -i | Ignora él case sensitive |

Buscar texto dentro de un archivo con el comando `grep`. "Grep" significa Global Regular Expression Print. El comando `grep` utiliza regex (Regular Expression) para realizar su búsqueda, si no sabes como armar un regex aquí tienes el Curso de Expresiones Regulares

`grep [ExpresiónRegular] [archivoDondeBuscar]`

- Buscar la palabra `the` en el archivo: `grep the movies.csv`
- Ignorar case sensitive (-i): `grep -i Action movies.csv`, buscará independientemente de si la letra "A" es mayúscula o minúscula.
- Contar ocurrencias (-c): `grep -c Drama movies.csv`, si quieres saber cuántas veces se repite una palabra.
- Excluir una expresión (-v): `grep -cv Drama movies.csv`, saber cuáles son los resultados que NO coinciden con tu expresión regular. Queremos contar todas las películas que no son de drama.
- Limitar la búsqueda (-m): `grep -m 10 Fan movies.csv`, queremos buscar las primeras 10 líneas que concuerden con la palabra `"Fan"`.


> Archivo empleado: [movies.csv](/files/movies.csv)

### Comando **nerd**

El comando `wc` (word count) se utiliza en la terminal para contar líneas, palabras y caracteres en archivos de texto. Al ejecutar wc, puedes usar opciones como `-l` para contar líneas, `-w` para contar palabras y `-c` para contar caracteres. 

Por ejemplo, `wc -l archivo.txt` mostrará el número de líneas en "archivo.txt". Este comando es útil para obtener rápidamente estadísticas sobre el contenido de archivos y resulta complementario al uso de grep para filtrar y buscar información específica dentro de textos.

# Utilidades de la terminal

## Red

| Comando | Función | 
| --- | --- | 
| ifconfig | Muestra la configuración de los dispositivos de red | 
| ping | Envía paquetes a una dirección para comprobar su conectividad | 
| curl | Muestra por consola el archivo devuelto por la dirección | 
| wget | Guarda el archivo devuelto por la dirección |

El manejo de redes es bastante amplio, de hecho, es toda una rama de la informática. Aquí aprenderás comandos básicos de utilidades de la red para que puedas obtener la información que necesites.

- Configuración de tus dispositivos `ifconfig`
- Enviar solicitudes a una página `ping`
  - Para limitar la cantidad de paquetes que enviamos, usamos la opción `-c` seguida del número de paquetes por enviar. `ping -c 4 www.google.com`
  - Para probar la conectividad con paquetes de diferentes tamaños se utiliza la opción `-s` seguido del tamaño del paquete que desees usar. El tamaño debe ser en bytes. `ping -s 20 www.google.com`
- Podemos obtener archivos que nos proporcione un sitio web o dirección IP con el comando `curl`. Este te mostrará la información que haya encontrado en la consola. `curl www.google.com`
- El comando `wget` hace algo similar, solo que en vez de mostrar lo que h obtenido por consola lo guarda en el archivo que le especifiques. `wget www.google.com` 
  - También podemos específicar varias direcciones para descargar varias páginas al mismo tiempo. `wget www.google.com www.platzi.com`
- Cuando nos conectamos a una página en internet no nos conectamos directamente a los servidores en los que está almacenada esa página, sino que primero pasamos por otros servidores que son como intermediarios entre tu computadora y el servidor.`traceroute`
- Mostrar dispositivos de red `netstat -i`.

## Comprimir archivos

Para comprimir con este formato en la terminal usamos el comando `tar` que tiene ciertas opciones para aprender.

`tar [opciones] [nombreDelArchivoComprimido] [archivoAComprimir]`

- Para comprimir un archivo utilizamos la opción `-c`. En todos los casos hay que usar la opción `-f` para indicar que estamos comprimiendo o descomprimiendo archivos. `tar -cf compressed.tar Documents/toCompress/`
- Si queremos ver lo que el comando está comprimiendo a medida que se va ejecutando, usamos la opción `-v`. Por cierto la opción `-v` es de "Verbose" y muchos comandos la usan, también te la puedes encontrar como `--verbose`. `tar -cvf compressed.tar Documents/toCompress/`
- Para manejar la compresión de archivos ".tar.gz" o ".tgz" se usa la opción `-z` además de tener que especificar en el nombre de archivo la extensión que quieres usar. `tar -czvf compressed.tar.gz Documents/toCompress/`
- Si se quiere descomprimir un archivo de extensión ".tar.gz" o ".tgz" hay que especificar la opción `-z` también. `tar -xzvf compressed.tar.gz`
- Si quieres comprimir una carpeta con archivos dentro, tienes que especificar la opción `-r` de "recursive". `zip -r copressed.zip Documents/toCompress/`
- Para descomprimir es incluso más fácil, solo escribe el comando `unzip` seguido de lo que quieres descomprimir. `unzip compressed.zip`

| Opción | Función | 
| --- | --- | 
| c | Comprimir | 
| x | Descomprimir | 
| z | Especifica que lo que se va a comprimir o descomprimir tiene extensión ".tar.gz" o ".tgz" | 
| v | Muestra lo que está comprimiendo o descomprimiendo |

> Recuerda siempre colocar la opción -f.

| Comando | Función | 
| --- | --- | 
| zip | Comprimir | 
| unzip | Decomprimir |

## Manejo de Procesos

Puedes manejar los procesos como visualizar, eliminar o filtrar desde la terminal.

- El comando `ps` muestra los procesos que están activos en una tabla muy sencilla de entender, donde el la primera columna tenemos el process ID y en la última el nombre.
- Si quieres ver una lista más detallada de los procesos con su consumo en CPU y en RAM, además del usuario que lo activó, usamos el comando `top`.
   - Aquí podemos filtrar por user. Si presionas la tecla "u" podrás escribir el nombre de usuario por el cual quieres buscar y si presionas la tecla "h" te mostrará un cuadro de ayuda para más opciones. Para salir presiona "q".
- Para matar un proceso usamos el comando `kill` seguido del PID del proceso que queremos matar.

| Comando | Función | 
| --- | --- | 
| ps | Muestra una tabla con los procesos que se están ejecutando | 
| top | Muestra una interfaz con los procesos que se están ejecutando más los recursos que consumen información adicional | 
| kill | Mata el proceso que le indiques |

## Procesos en foreground y background

Podemos correr de manera asíncrona comandos, y si estos no se completan quedarán activos dentro de los procesos de la terminal. Cuando un proceso está en ejecución sin que sea mostrado en la terminal se dice que se está ejecutando en el background. Si se muestra la ejecución del comando dentro de la terminal se dice que está en el foreground. 

Imagina que queremos una nota desde la terminal y para eso usamos: `cat > mi_nota.txt`. Nuestra terminal se verá de la siguiente manera, con el prompt esperando a que ingresemos texto. 

Podemos escribir algo y después terminar el input del texto con `CTRL+D`, pero en esta ocasión no haremos eso. Lo que queremos hacer será suspender el proceso, esto lo podemos hacer con `CTRL+Z`. El resultado que nos mostrará la terminal deberá ser uno donde nos indique la suspensión del comando `cat`. 

```bash
[1]  + 26403 suspended  cat > mi_nota.txt
```

Ahora hemos movido nuestro comando exitosamente al `background` de la terminal. Para consultar todos los procesos que tenemos en `background` podemos hacerlo con el comando `jobs`.
```bash
[1]  + suspended  cat > mi_nota.txt
```

A la izquierda aparece el número del trabajo (⚠ cuidado que no es lo mismo que el process ID). Si queremos traer la ejecución de nuevo a la terminal, es decir, al foreground; debemos usar el comando `fg` y especificar qué número de trabajo queremos continuar.
```bash
fg 1
```
Si usas **ZSH**
```bash
fg %1
[1]  + 26403 continued  cat > mi_nota.txt
```
Una vez enviado al foreground veremos como se activa la ejecución del comando en la terminal y podremos seguir escribiendo nuestra nota. Recuerda que una vez terminemos de escribir presionamos `CTRL+D`para terminar el input y guardar.

Otra forma de enviar al background `cat > mi_nota.txt &`, otra opción `bg 1` este sirve de manera similar que `fg` solo que en vez de traerlo al `foreground` este lleva un trabajo al `background`.

## Editores de texto en la terminal

Existen varios editores de texto que se utilizan en la terminal, y aquí un breve resumen de los más populares:

- Vim: Es un editor muy potente y popular entre desarrolladores. Ofrece modos de inserción y normal, resaltado de sintaxis y es altamente configurable. Requiere tiempo para aprender, pero es muy eficiente una vez dominado.

- Nano: Es un editor más simple y fácil de usar, ideal para principiantes. Su interfaz es amigable y no requiere complejas combinaciones de teclas, haciéndolo accesible para todos.

- Emacs: Es un editor versátil, conocido por su extensibilidad. Permite personalizaciones profundas y tiene una curva de aprendizaje más pronunciada, pero es muy poderoso para quienes lo dominan.

Cada uno tiene sus ventajas y desventajas, y la elección depende de las preferencias y necesidades del usuario.

## Personalizar la terminal de comandos

En la personalización de la terminal se pueden realizar los siguientes tipos:

- Cambiar el emulador de terminal: Como TILIX para Linux, que permite dividir la ventana en varias terminales.
- Instalar una nueva shell: Por ejemplo, Zsh, que mejora la experiencia con funciones adicionales.
- Configurar un tema: Usar temas como Powerlevel10k, que ofrecen visualización avanzada y colores.
- Modificar la fuente: Elegir fuentes que permitan mostrar íconos y mejorar la estética.
- Configurar archivos de configuración: Editar el archivo .zshrc para personalizar la funcionalidad de la shell.

Estas personalizaciones hacen que la terminal sea más cómoda y visualmente atractiva.

### Enlaces

- <https://platzi.com/blog/terminal-en-big-sur-mas-bonita-que-nunca/>
- <https://gnunn1.github.io/tilix-web/>
- <https://ohmyz.sh/>
- <https://github.com/romkatv/powerlevel10k>
- <https://www.edevars.com/blog/personalizar-terminal>


# Next

Recomendaciones de lectura:
- <https://nostarch.com/linuxbasicsforhackers>
- <https://nostarch.com/tlcl2>
- <https://www.oreilly.com/library/view/grep-pocket-reference/9780596157005/>
- <https://www.oreilly.com/library/view/learning-the-vi/9780596529833/>
- <https://www.oreilly.com/library/view/linux-pocket-guide/9781491927557/>
- <https://www.oreilly.com/library/view/regular-expression-pocket/9780596514273/>

# Instalando WSL

**WSL** es la base con la que haremos que alguna distribución de Linux pueda correr dentro de nuestra computadora con Windows 10 u 11. 

Una vez que se tenga instalada esta herramienta podrás instalar una gran variedad de distribuciones de Linux como Ubuntu o Debian. Para nuestro caso instalaremos Ubuntu que se instala por defecto al instalar WSL, pero puedes escoger alguna otra por la que tengas preferencia y ya sepas utilizar.

1. Abre Windows PowerShell desde inicio en Widows. Para ello búscala y da clic derecho sobre Ejecutar como Administrador.
2. Dentro de Windows PowerShell escribe la siguiente instrucción y presiona la tecla Enter: `wsl --install`
3. Espera a que la barra de instalación llegue al 100% y presiona `Enter` nuevamente. Eso iniciará el proceso de instalación del sistema operativo Ubuntu.
4. Espera a que la barra de instalación de Ubuntu llegue al 100%.
5. A finalizar la instación reinicia tu computadora para aplicar los cambios.
6. Una vez que se haya reiniciado la computadora te llevará a configurar Ubuntu.
7. Ingresa el username y password de tu preferencia. Recuerda muy bien tu password, ya que deberás usarla al utilizar el sistema operativo Ubuntu desde WSL.
8. Listo, ya tienes WSL y Ubuntu instalados en tu computadora con Windows. Para acceder nuevamente a Ubuntu en WSl abre la aplicación Terminal desde inicio de Windows.
9. Dentro de Terminal da clic en la flecha hacia abajo y elige la opción de Ubuntu.

Para más información en la [documentación oficial de Microsoft](https://learn.microsoft.com/es-mx/windows/wsl/install) sobre **WSL**.

# Principios de usabilidad y Heurís­stica:

1. **Visibilidad del estado del sistema:** el usuario deberá saber que  está pasando en cada interacción con el producto (cargando, guardando,  errores). Debe recibir un feedback del estado del producto.
2.  **Relación producto y mundo real:** El usuario no deberá tener dudas al  momento de interactuar con el sistema, se le debe brindar toda la  información para que pueda operar el sistema.
3.  **Control y libertad del usuario**: El usuario debe poder cancelar o salir de un proceso, sin finalizarlo y sin compromisos.
4. **Consistencia:** En el diseño de los bloques visuales del flujo del  sistema, tratar de llevar un patrón en todos los elementos del sistema.
5. **Prevención de errores:** Proveer instrucciones claras de lo que se espera que el usuario realice dentro de nuestro producto.
6. **Reconocer antes de recordar:** Entregar información valiosa al usuario y ademas proveer una forma en que el usuario pueda revisarla cuando la  necesite sin acudir a su memoria.
7. **Flexibilidad y eficiencia de uso:** Entregar una interfaz capaz de  satisfacer a usuarios avanzados y no avanzados. Permitir el uso del  producto sin necesidad de conocimientos especializados.
8. **Diseño estático y minimalista:** no saturar de contenido al usuario, mostrar únicamente el contenido relevante para cada vista o cada acción que el usuario ha decidido acceder. No poner elementos que distraigan al usuario del objetivo de la vista.
9. **Ayudar al usuario a reconocer y corregir errores:** Dar información al  usuario de lo que esta generando errores o inconsistencias en el  sistema.
10. **Ayuda y documentación:** Detectar las dudas mas comunes de los  usuarios a la hora de usar nuestro producto y proveer información que  pueda resolverlas de manera inmediata.

# Recursos

 - [Command Line Cheat Sheet](/files/command-line-cheat-sheet.pdf)

# Atención

Este tutorial es basado en el Curso de Introducción a la Terminal y Línea de Comandos de Platzi.